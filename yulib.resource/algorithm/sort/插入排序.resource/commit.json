{"compress":true,"commitItems":[["e6ae4595-0d08-401a-965e-77d6b370935b",1569059639017,"",[[1569059605823,["sirui-php@DESKTOP-PSVFMK8",[[1,0,"# 插入排序\n\n\n\n"]],[0,0],[9,9]]],[1569059626982,["sirui-php@DESKTOP-PSVFMK8",[[1,9,"<?php\n\n/**\n * 插入排序\n * @author   ShaoWei Pu <pushaowei0727@gmail.com>\n * @date     2017/6/17\n * @license  MIT\n * -------------------------------------------------------------\n * 思路分析：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。\n * -------------------------------------------------------------\n *\n * 算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。\n * 插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，\n * 但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。\n * 在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。\n *\n */\n\n\n// +--------------------------------------------------------------------------\n// | 解题方式    | 这儿，可能有用的解决方案\n// +--------------------------------------------------------------------------\n\n/**\n * InsertSort\n *\n * @param array $container\n * @return array\n */\nfunction InsertSort(array $container)\n{\n    $count = count($container);\n    for ($i = 1; $i < $count; $i++){\n        $temp = $container[$i];\n        $j    = $i - 1;\n        // Init\n        while($j >= 0 && $container[$j] > $temp){\n            $container[$j+1] = $container[$j];\n            $j--;\n        }\n        if($i != $j+1) \n            $container[$j+1] = $temp;\n    }\n    return $container;\n}\n\n\n// +--------------------------------------------------------------------------\n// | 方案测试    | php `this.php` || PHPStorm -> 右键 -> Run `this.php`\n// +--------------------------------------------------------------------------\nvar_dump(InsertSort([3, 12, 42, 1, 24, 5, 346, 7]));\n\n/*\narray (size=8)\n  0 => int 1\n  1 => int 3\n  2 => int 5\n  3 => int 7\n  4 => int 12\n  5 => int 24\n  6 => int 42\n  7 => int 346\n */\n"]],[9,9],[1553,1553]]],[1569059628044,["sirui-php@DESKTOP-PSVFMK8",[[-1,9,"<?php\n\n/**\n * 插入排序\n * @author   ShaoWei Pu <pushaowei0727@gmail.com>\n * @date     2017/6/17\n * @license  MIT\n * -------------------------------------------------------------\n * 思路分析：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。\n * -------------------------------------------------------------\n *\n * 算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。\n * 插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，\n * 但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。\n * 在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。\n *\n */\n\n\n// +--------------------------------------------------------------------------\n// | 解题方式    | 这儿，可能有用的解决方案\n// +--------------------------------------------------------------------------\n\n/**\n * InsertSort\n *\n * @param array $container\n * @return array\n */\nfunction InsertSort(array $container)\n{\n    $count = count($container);\n    for ($i = 1; $i < $count; $i++){\n        $temp = $container[$i];\n        $j    = $i - 1;\n        // Init\n        while($j >= 0 && $container[$j] > $temp){\n            $container[$j+1] = $container[$j];\n            $j--;\n        }\n        if($i != $j+1) \n            $container[$j+1] = $temp;\n    }\n    return $container;\n}\n\n\n// +--------------------------------------------------------------------------\n// | 方案测试    | php `this.php` || PHPStorm -> 右键 -> Run `this.php`\n// +--------------------------------------------------------------------------\nvar_dump(InsertSort([3, 12, 42, 1, 24, 5, 346, 7]));\n\n/*\narray (size=8)\n  0 => int 1\n  1 => int 3\n  2 => int 5\n  3 => int 7\n  4 => int 12\n  5 => int 24\n  6 => int 42\n  7 => int 346\n */\n"]],[1553,1553],[9,9]]],[1569059631790,["sirui-php@DESKTOP-PSVFMK8",[[1,9,"# 选择排序\n\n* 思路分析： 选择排序是不稳定的排序方法，它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。\n\n* 算法步骤\n  1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n\n  2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n  3. 重复第二步，直到所有元素均排序完毕。\n  \n* 代码样式\n\n```php\n/**\n * 选择排序\n *\n * @param array $container\n * @return array\n */'\nfunction SelectSort(array $container)\n{\n    $count = count($container);\n    for ($i = 0; $i < $count; $i++){\n        $k = $i;\n        for ($j = $i + 1; $j < $count; $j++){\n            if($container[$j] < $container[$k]){\n                $k = $j;\n            }\n        }\n        if($k != $i){\n            $temp          = $container[$i];\n            $container[$i] = $container[$k];\n            $container[$k] = $temp;\n        }\n    }\n    return $container;\n}\n\n```\n"]],[9,9],[821,821]]],[1569059632735,["sirui-php@DESKTOP-PSVFMK8",[[-1,0,"# 插入排序\n\n\n"]],[0,822],[812,812]]],[1569059634623,["sirui-php@DESKTOP-PSVFMK8",[[-1,2,"选择排序"],[1,6,"c"]],[2,6],[3,3]]],[1569059634983,["sirui-php@DESKTOP-PSVFMK8",[[1,3,"ha"]],[3,3],[5,5]]],[1569059635606,["sirui-php@DESKTOP-PSVFMK8",[[-1,2,"cha"]],[5,5],[2,2]]],[1569059636263,["sirui-php@DESKTOP-PSVFMK8",[[1,2,"cha"]],[2,2],[5,5]]],[1569059636918,["sirui-php@DESKTOP-PSVFMK8",[[-1,2,"cha"]],[5,5],[2,2]]],[1569059638681,["sirui-php@DESKTOP-PSVFMK8",[[1,2,"插入排序"]],[2,2],[6,6]]],[1569059649560,["sirui-php@DESKTOP-PSVFMK8",[[-1,16,"选择排序是不稳定的排序方法，它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始"],[1,73,"每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当"],[1,75,"上"],[-1,80,"待排序的数据元素排完。选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）"],[1,152,"插入完为止"]],[16,153],[65,65]]],[1569059686062,["sirui-php@DESKTOP-PSVFMK8",[[1,65,"插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。"]],[65,65],[183,183]]],[1569059696172,["sirui-php@DESKTOP-PSVFMK8",[[1,192,"*"],[-1,194,"1. 首先在未"],[1,201," 将第一待"],[-1,205,"中找到最小（大）元素，存放到"],[1,219,"第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未"],[-1,223,"的起始位置"],[1,228,"。"],[1,230,"*"],[-1,232,"2. 再从剩余"],[1,239," 从头到尾依次扫描"],[1,242,"序列，将扫描到的每个"],[-1,244,"中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n  3. 重复第二步，直到所有元素均排序完毕。"],[1,295,"插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）"]],[192,295],[323,323]]],[1569059698150,["sirui-php@DESKTOP-PSVFMK8",[[-1,192,"* "]],[194,194],[192,192]]],[1569059698302,["sirui-php@DESKTOP-PSVFMK8",[[-1,191,"\n"]],[192,192],[191,191]]],[1569059698944,["sirui-php@DESKTOP-PSVFMK8",[[1,191,"\n"]],[191,191],[192,192]]],[1569059700573,["sirui-php@DESKTOP-PSVFMK8",[[1,192,"1、"]],[192,192],[194,194]]],[1569059701416,["sirui-php@DESKTOP-PSVFMK8",[[-1,193,"、"]],[194,194],[193,193]]],[1569059701696,["sirui-php@DESKTOP-PSVFMK8",[[1,193,"/"]],[193,193],[194,194]]],[1569059702374,["sirui-php@DESKTOP-PSVFMK8",[[-1,193,"/"]],[194,194],[193,193]]],[1569059702591,["sirui-php@DESKTOP-PSVFMK8",[[1,193,"."]],[193,193],[194,194]]],[1569059702856,["sirui-php@DESKTOP-PSVFMK8",[[1,196," "]],[194,194],[195,195]]],[1569059703798,["sirui-php@DESKTOP-PSVFMK8",[[1,192,"  "]],[192,192],[194,194]]],[1569059705303,["sirui-php@DESKTOP-PSVFMK8",[[-1,245,"* "]],[247,247],[245,245]]],[1569059705695,["sirui-php@DESKTOP-PSVFMK8",[[1,247,"  "]],[245,245],[247,247]]],[1569059706431,["sirui-php@DESKTOP-PSVFMK8",[[1,247,"2."]],[247,247],[249,249]]],[1569059717933,["sirui-php@DESKTOP-PSVFMK8",[[-1,354,"选择排序"],[1,358,"InsertSort"],[-1,409,"'"],[-1,420,"Selec"],[1,425,"Inser"],[-1,497,"0"],[1,498,"1"],[-1,529,"k"],[1,530,"temp"],[1,534,"conta"],[1,535,"ner[$i]"],[-1,545,"for ("],[1,553,"   "],[-1,558,"+"],[1,559,"-"],[1,562,"\n        // Init\n      "],[1,563," while("],[-1,566,"<"],[1,567,">= 0 &&"],[-1,571,"u"],[-1,574,"; $j++"],[1,580,"ainer[$j] > $temp"],[-1,595,"if("],[1,611,"+1"],[-1,613,"<"],[1,614,"="],[-1,627,"k]){\n    "],[1,636,"j];\n"],[-1,649,"k = $"],[1,655,"--"],[-1,657,"            }\n"],[-1,693,"k"],[1,694,"i"],[-1,699,"i){\n            $temp          = $container[$i];"],[1,747,"j+1) "],[-1,772,"i] = $container[$k];\n            $container[$k"],[1,818,"j+1"],[-1,828,"\n        }"]],[347,869],[814,814]]],[1569059721129,["sirui-php@DESKTOP-PSVFMK8",[[-1,354,"InsertSort"],[1,364,"插入"]],[354,354],[356,356]]],[1569059721794,["sirui-php@DESKTOP-PSVFMK8",[[1,356,"排序"]],[356,356],[358,358]]]],null,"sirui-php@DESKTOP-PSVFMK8"]]}