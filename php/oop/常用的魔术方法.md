# 常用的魔术方法


## __get() 和 __set()

**==初衷==**：一般来说，总是把类的属性定义为private，这更符合现实的逻辑，因为把类的属性定义成private 外面就无法修复其值，保证了属性的安全性，这样属性就不会随意的被赋值上任何非法的值了，但是， 对属性的读取和赋值操作是非常频繁的，因此在PHP5中，预定义了两个函数”__get()”和”__set()”来获取和赋值其属性，这时候有人就会问了，为什么一定要把属性定义成private 又要有__get() 和 __set() 直接定义成public 不行吗，小编这里给出以下几点解释
1. 了不让其示例对象直接通过 对象.属性名 来使用和修改，而是通过set属性名,更安全，这样属性就不会随意的被赋值上任何非法的值了，可以在set属性名的方法中进行控制
2. 假设有很多等级的用户呢？只让其中某一种人有权访问，_get 里就可以做身份验证
3. 你也许会天真的以为你自己写的东西我自己难道不知道嘛，那你就错了，很多时候你写的东西是要给很多人用的，或者你要用别人实现的很多东西。

### __get()方法

这个方法用来获取私有成员属性值的，有一个参数， 参数传入你要获取的成员属性的名称，返回获取的属性值， 这个方法不用我们手工的去调用， 是在直接获取私有属性的时候自动调用的。因为私有属性已经被封装上了，是不能直接获取值的（比如：”echo $p1->name” 这样直接获取是错误的），但是如果你在类里面加上了这个方法，在使用”echo $p1->name” 这样的语句直接获取值的时候就会自动调用__get($property_name)方法，将属性name传给参数$property_name，通过这 个方法的内部执行，返回我们传入的私有属性的值。

### __set()方法

这个方法用来为私有成员属性设置值的， 有两个参数，第一个参数为你要为设置值的属性名，第二个参数是要给属性设置的值，没有返回值。这个方法同样不用我们手工去调用，是在直接设置私有属性值的 时候自动调用的，同样属性私有的已经被封装上了， 如果没有__set()这个方法，是不允许的， 比如：”$this->name=’zhangsan’，这样会出错，但是如果你在类里面加上了__set($property_name, $value)这个方法，在直接给私有属性赋值的时候，就会自动调用它，把属性比如name传给$property_name， 把要赋的值”zhangsan”传给$value，通过这个方法的执行，达到赋值的目的， 为了不传入非法的值， 还可以在这个方法给做一下判断。代码如下：

```php
1	<?php
2	class Person
3	{
4	    // 下面是人的成员属性， 都是封装的私有成员
5	    private $name;      //人的名子
6	    private $sex;       //人的性别
7	    private $age;       //人的年龄
8
9	    //__get()方法用来获取私有属性
10	    function __get($property_name)
11	    {
12	        echo "在直接获取私有属性值的时候，自动调用了这个__get()方法<br />";
13	        if (isset($this->$property_name))
14	        {
15	            return ($this->$property_name);
16	        }
17	        else
18	        {
19	            return NULL;
20	        }
21	    }
22
23	    //__set()方法用来设置私有属性
24	    function __set($property_name, $value)
25	    {
26	        echo "在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值<br />";
27	        $this->$property_name = $value;
28	    }
29	}
30
31	$p1 = new Person();
32
33	// 直接为私有属性赋值的操作， 会自动调用__set()方法进行赋值
34	$p1->name = "张三";
35	$p1->sex = "男";
36	$p1->age = 20;
37
38	// 直接获取私有属性的值， 会自动调用__get()方法，返回成员属性的值
39	echo "姓名：" . $p1->name . "<br />";
40	echo "性别：" . $p1->sex . "<br />";
41	echo "年龄：" . $p1->age . "<br />";
42	?>

```

程序执行结果：

```
在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值
在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值
在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值
在直接获取私有属性值的时候，自动调用了这个__get()方法
姓名：张三
在直接获取私有属性值的时候，自动调用了这个__get()方法
性别：男
在直接获取私有属性值的时候，自动调用了这个__get()方法
年龄：20

```

以上代码如果不加上__get()和__set()方法，程序就会出错，因为不能在类的外部操作私有成员，而上面的代码是通过自动调用__get()和__set()方法来帮助我们直接存取封装的私有成员的。

## __isset() 方法 和 __unset()

### __isset() 方法

在看这个方法之前我们看一下“isset()”函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。那么如果在一个对象外面使用“isset()”这个函数去测定对象里面的成员是否被设定可不可以用它呢？分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用“isset()”函数来测定私有成员属性是否被设定了呢？可以，你只要在类里面加上一个“__isset()”方法就可以了，当在类外部使用”isset()”函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的“__isset()”方法了帮我们完成这样的操作，“__isset()”方法也可以做成私有的。你可以在类里面加上下面这样的代码就可以了：

```php
1	private function __isset($nm)
2	{
3	    echo "当在类外部使用isset()函数测定私有成员$nm时，自动调用<br />";
4
5	    return isset($this->$nm);
6	}
```

### __unset()方法

看这个方法之前呢，我们也先来看一下“unset()”这个函数，“unset()”这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。那么如果在一个对象外部去删除对象内部的成员属性用“unset()”函数可不可以呢，也是分两种情况，如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性，如果对象的成员属性是私有的，我使用这个函数就没有权限去删除，但同样如果你在一个对象里面加上“__unset()”这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了“__unset()”这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，自动调用“__unset()”函数来帮我们删除对象内部的私有成员属性，这个方法也可以在类的内部定义成私有的。在对象里面加上下面的代码就可以了：

```
1	private function __unset($nm)
2	{
3	    echo "当在类外部使用unset()函数来删除私有成员时自动调用的<br />";
4	    unset($this->$nm);
5	}

```

我们来看一个完整的实例：

```php
1	<?php
2	class Person
3	{
4	    // 下面是人的成员属性
5	    private $name;      //人的名子
6	    private $sex;       //人的性别
7	    private $age;       //人的年龄
8
9	    // __get()方法用来获取私有属性
10	    private function __get($property_name)
11	    {
12	        if (isset($this->$property_name))
13	        {
14	            return ($this->$property_name);
15	        }
16	        else
17	        {
18	            return NULL;
19	        }
20	    }
21
22	    // __set()方法用来设置私有属性
23	    private function __set($property_name, $value)
24	    {
25	        $this->$property_name = $value;
26	    }
27
28	    // __isset()方法
29	    private function __isset($nm)
30	    {
31	        echo "isset()函数测定私有成员时，自动调用";
32	        return isset($this->$nm);
33	    }
34
35	    //__unset()方法
36	    private function __unset($nm)
37	    {
38	        echo "当在类外部使用unset()函数来删除私有成员时自动调用的<br />";
39	        unset($this->$nm);
40	    }
41	}
42
43	$p1 = new Person();
44	$p1->name = "this is a person name";
45
46	// 在使用isset()函数测定私有成员时，自动调用__isset()方法帮我们完成，返回结果为true
47	echo var_dump(isset($p1->name)) . "<br >";
48	echo $p1->name . "<br />";
49
50	// 在使用unset()函数删除私有成员时，自动调用__unset()方法帮我们完成，删除name私有属性
51	unset($p1->name);
52
53	// 已经被删除了，所这行不会有输出
54	echo $p1->name;
55	?>

```

输出结果为：

```php
isset()函数测定私有成员时，自动调用
boolean true
this is a person name
当在类外部使用unset()函数来删除私有成员时自动调用的
isset()函数测定私有成员时，自动调用
```

## __toString()方法

我们前面说过在类里面声明“__”开始的方法名的方法（PHP给我们提供的），都是在某一时刻不同情况下自动调用执行的方 法。
“__toString()”方法也是一样自动被调用的，是在直接输出对象引用时自动调用的， 前面我们讲过对象引用是一个指针，比如 说：“`$p=new Person()`“中，$p就是一个引用，我们不能使用echo 直接输出$p，这样会输 出
`Catchable fatal error: Object of class Person could not be converted to string`这样的错误。

如果你在类里面定义了“__toString()”方法，在直接输出对象引用的时候，就不会产生错误，而是自动调用 了”__toString()”方法， 输出“__toString()”方法中返回的字符，所以“__toString()”方法一定要有个返回值（return 语句）。

```php
1	<?php
2	// Declare a simple class
3	class TestClass
4	{
5	    public $foo;
6
7	    public function __construct($foo) {
8	        $this->foo = $foo;
9	    }
10
11	    //定义一个__toString方法，返加一个成员属性$foo
12	    public function __toString() {
13	        return $this->foo;
14	    }
15	}
16
17	$class = new TestClass('Hello');
18
19	//直接输出对象
20	echo $class;
21	?>

```

上例输出：

```
Hello
```

##  __clone()

有的时候我们需要在一个项目里面，使用两个或多个一样的对象，如果你使用“new”关键字重新创建对象的话，再赋值上相同的属性，这样做比较烦琐而且也容易出错，所以要根据一个对象完全克隆出一个一模一样的对象，是非常有必要的，而且克隆以后，两个对象互不干扰。

在PHP中我们使用“clone”这个关键字克隆对象；

```php
1	<?
2	class Person
3	{
4	    //下面是人的成员属性
5	    var $name;  //人的名子
6	    var $sex;   //人的性别
7	    var $age;   //人的年龄
8
9	    //定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值
10	    function __construct($name = "", $sex = "", $age = "") {
11	        $this->name=$name;
12	        $this->sex=$sex;
13	        $this->age=$age;
14	    }
15
16	    //这个人可以说话的方法，说出自己的属性
17	    function say() {
18	        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age . "<br>";
19	    }
20	}
21
22	$p1 = new Person("张三", "男", 20);
23
24	//使用“clone”克隆新对象p2，和p1对象具有相同的属性和方法。
25	$p2=clone $p1;
26	$p2->say();
27	?>

```

PHP定义了一个特殊的方法名“__clone()”方法，是在对象克隆时自动调用的方法，用“__clone()”方法将建立一个与原对象拥有相同属 性和方法的对象，如果想在克隆后改变原对象的内容，需要在__clone()中重写原本的属性和方法， “__clone()”方法可以没有参数，它自 动包含$this和$that两个指针，$this指向复本，而$that指向原本；

```php
1	<?
2	class Person
3	{
4	    //下面是人的成员属性
5	    var $name;  //人的名子
6	    var $sex;   //人的性别
7	    var $age;   //人的年龄
8
9	    //定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值
10	    function __construct($name = "", $sex = "", $age = "") {
11	        $this->name=$name;
12	        $this->sex=$sex;
13	        $this->age=$age;
14	    }
15
16	    //这个人可以说话的方法, 说出自己的属性
17	    function say() {
18	        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age . "<br>";
19	    }
20
21	    //对象克隆时自动调用的方法, 如果想在克隆后改变原对象的内容，需要在__clone()中重写原本的属性和方法
22	    function __clone() {
23
24	        //$this指的复本p2, 而$that是指向原本p1，这样就在本方法里，改变了复本的属性。
25	        $this->name = "我是假的 $that->name";
26	        $this->age = 30;
27	    }
28
29	}
30
31	$p1 = new Person("张三", "男", 20);
32	$p2 = clone $p1;
33	$p1->say();
34	$p2->say();
35	?>

```

上例输出：

```
我的名子叫：张三 性别：男 我的年龄是：20
我的名子叫：我是假的张三 性别：男 我的年龄是：30
```

## __call()处理调用错误

在程序开发中，如果在使用对象调用对象内部方法时候，调用的这个方法不存在那么程序就会出错，然后程序退出不能继续执行。那么可不可以在程序调用对象内部 不存在的方法时，提示我们调用的方法及使用的参数不存在，但程序还可以继续执行，这个时候我们就要使用在调用不存在的方法时自动调用的方 法“__call()”。

```php
1	<?php
2	//这是一个测试的类，里面没有属性和方法
3	class Test
4	{
5
6	}
7
8	//产生一个Test类的对象
9	$test = new Test();
10
11	//调用对象里不存在的方法
12	$test->demo("one", "two", "three");
13
14	//程序不会执行到这里
15	echo "this is a test<br>";
16	?>

```

上例出现如下错误，程序通出不能继续执行

```
1	Fatal error: Call to undefined method Test::demo()

```

下面我们加上“__call()”方法，这个方法有2个参数，第一个参数为调用不存在的方法过程中，自动调用__call()方法时，把这个不存在的方法的方法名传给第一个参数，第二个参数则是把这个方法的多个参数以数组的形式传进来。

```php
1	<?php
2	//这是一个测试的类，里面没有属性和方法
3	class Test
4	{
5	    //调用不存的方法时自动调用的方法，第一个参数为方法名，第二个参数是数组参数
6	    function __call($function_name, $args) {
7
8	        print "你所调用的函数：$function_name(参数：";
9	        print_r($args);
10	        echo ")不存在！<br>
11	";
12	    }
13	}
14
15	//产生一个Test类的对象
16	$test=new Test();
17
18	//调用对象里不存在的方法
19	$test->demo("one", "two", "three");
20
21	//程序不会退出可以执行到这里
22	echo "this is a test<br>";
23	?>

```

上例输出结果为：

```
你所调用的函数： demo(参数：Array ( [0] => one [1] => two [2] => three ) )不存在！
this is a test
```
