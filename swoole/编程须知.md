## 1. 禁止使用sleep以及其它睡眠函数
在异步IO的程序中，**不得使用sleep/usleep/time_sleep_until/time_nanosleep**。（下文中使用`sleep`泛指所有睡眠函数）

*   `sleep`函数会使进程陷入睡眠阻塞
*   直到指定的时间后操作系统才会重新唤醒当前的进程
*   `sleep`过程中，只有信号可以打断
*   由于`Swoole`的信号处理是基于`signalfd`实现的，所以即使发送信号也无法中断`sleep`

`Swoole`提供的`swoole_event_add`、`swoole_timer_tick`、`swoole_timer_after`、`swoole_process::signal`、`异步swoole_client` 在进程sleep后会停止工作。`swoole_server`也无法再处理新的请求。

## 2. 使用Exit/Die会导致Worker进程退出

在swoole程序中禁止使用exit/die，如果PHP代码中有`exit/die`，当前工作的Worker进程、Task进程、User进程、以及`swoole_process`进程会立即退出。

使用exit/die后Worker进程会因为异常退出, 被master进程再次拉起, 最终造成进程不断退出又不断启动和产生大量警报日志.

建议使用`try/catch`的方式替换`exit/die`，实现中断执行跳出`PHP`函数调用栈。

```
function swoole_exit($msg)
{
    //php-fpm的环境
    if (ENV=='php')
    {
        exit($msg);
    }
    //swoole的环境
    else
    {
        throw new Swoole\ExitException($msg);
    }
}

```

> 以上代码并未实现`ENV`常量和`Swoole\ExitException`，请自行实现

异常处理的方式比`exit/die`更友好，因为异常是可控的，`exit/die`不可控。在最外层进行try/catch即可捕获异常，仅终止当前的任务。Worker进程可以继续处理新的请求，而`exit/die`会导致进程直接退出，当前进程保存的所有变量和资源都会被销毁。如果进程内还有其他任务要处理，遇到`exit/die`也将全部丢弃。

## 3.通过register_shutdown_function来捕获致命错误

Server运行期一旦发生致命错误，那客户端连接将无法得到回应。如Web服务器，如果有致命错误应当向客户端发送Http 500 错误信息。

在PHP中可以通过register_shutdown_function + error_get_last 2个函数来捕获致命错误，并将错误信息发送给客户端连接。具体代码示例如下：

```
register_shutdown_function('handleFatal');

function handleFatal()
{
    $error = error_get_last();
    switch ($error['type'] ?? null) {
        case E_ERROR :
        case E_PARSE :
        case E_CORE_ERROR :
        case E_COMPILE_ERROR :
            $message = $error['message'] . PHP_EOL;
            if (isset($_SERVER['REQUEST_URI'])) {
                $message .= '[QUERY] ' . $_SERVER['REQUEST_URI'];
            }
            // log or send:
            // error_log($message);
            // $server->send($fd, $message);
            break;
    }
}
```

## 4.代码中如果有异常抛出，必须在回调函数中进行try/catch捕获异常，否则会导致工作进程退出

## 5. 不支持set_exception_handler，必须使用try/catch方式处理异常

## 6. Worker进程不得共用同一个Redis或MySQL等网络服务客户端

绝对不可以# 共用1个redis或mysql连接。必须每个进程单独创建`Redis`、`MySQL`、`PDO`连接，其他的存储客户端同样也是如此。原因是如果共用1个连接，那么返回的结果无法保证被哪个进程处理。持有连接的进程理论上都可以对这个连接进行读写，这样数据就发生错乱了。

**所以在多个进程之间，一定不能共用连接**

*   在`swoole_server`中，应当在`onWorkerStart`中创建连接对象
*   在`swoole_process`中，应当在`swoole_process->start`后，子进程的回调函数中创建连接对象
*   本页面所述信息对使用`pcntl_fork`的程序同样有效

## 示例

```
$serv = new swoole_server("0.0.0.0", 9502);

//必须在onWorkerStart回调中创建redis/mysql连接
$serv->on('workerstart', function($serv, $id) {
    $redis = new redis;
    $redis->connect('127.0.0.1', 6379);
    $serv->redis = $redis;
});

$serv->on('receive', function (swoole_server $serv, $fd, $from_id, $data) { 
    $value = $serv->redis->get("key");
    $serv->send($fd, "Swoole: ".$value);
});

$serv->start();
```

## 7. 异步编程

*   异步程序要求代码中不得包含任何同步阻塞操作
*   异步与同步代码不能混用，一旦应用程序使用了任何同步阻塞的代码，程序即退化为同步模式

## 8.  类/函数重复定义

新手非常容易犯这个错误，由于`Swoole`是常驻内存的，所以加载类/函数定义的文件后不会释放。因此引入类/函数的php文件时必须要使用`include_once`或`require_once`，否则会发生`cannot redeclare function/class` 的致命错误。

## 9. while循环的影响
异步程序如果遇到死循环，事件将无法触发。异步IO程序使用`Reactor模型`，运行过程中必须在`reactor->wait`处轮询。如果遇到死循环，那么程序的控制权就在while中了，`reactor`无法得到控制权，无法检测事件，所以IO事件回调函数也将无法触发。

> 密集运算的代码没有任何IO操作，所以不能称为阻塞

## 实例程序

```
$serv = new swoole_server("127.0.0.1", 9501);
$serv->set(['worker_num' => 1]);
$serv->on('receive', function ($serv, $fd, $reactorId, $data) {
    while(1)
    {
        $i ++;
    }
    $serv->send($fd, 'Swoole: '.$data);
});
$serv->start();

```

`onReceive`事件中执行了死循环，`server`无法再收到任何客户端请求，必须等待循环结束才能继续处理新的事件。

## 8. stat缓存清理
PHP底层对`stat`系统调用增加了`Cache`，在使用`stat`、`fstat`、`filemtime`等函数时，底层可能会命中缓存，返回历史数据。

可以使用`clearstatcache`函数清理文件`stat`缓存。

## 9. mt_rand随机数
在`Swoole`中如果在父进程内调用了`mt_rand`，不同的子进程内再调用`mt_rand`返回的结果会是相同的。所以必须在每个子进程内调用`mt_srand`重新播种。

> `shuffle`和`array_rand`等依赖随机数的`PHP`函数同样会受到影响

```
mt_rand(0, 1);
//开始
$worker_num = 16;

// fork 进程
for($i = 0; $i < $worker_num; $i++) {
    $process = new swoole_process('child_async', false, 2);
    $pid = $process -> start();
}

//异步执行进程
function child_async(swoole_process $worker) {
    mt_srand();
    echo mt_rand(0, 100).PHP_EOL;
    $worker->exit();
}
```

## 10. 进程隔离

进程隔离也是很多新手经常遇到的问题。修改了全局变量的值，为什么不生效，原因就是全局变量在不同的进程，内存空间是隔离的，所以无效。所以使用`Swoole`开发`Server`程序需要了解`进程隔离`问题。

*   不同的进程中PHP变量不是共享，即使是全局变量，在A进程内修改了它的值，在B进程内是无效的
*   如果需要在不同的Worker进程内共享数据，可以用`Redis`、`MySQL`、`文件`、`Swoole\Table`、`APCu`、`shmget`等工具实现
*   不同进程的文件句柄是隔离的，所以在A进程创建的Socket连接或打开的文件，在B进程内是无效，即使是将它的fd发送到B进程也是不可用的

#### 实例：

```
$server = new Swoole\Http\Server('127.0.0.1', 9500);

$i = 1;

$server->on('Request', function ($request, $response) {
    global $i;
    $response->end($i++);
});

$server->start();

```

在多进程的服务器中，`$i`变量虽然是全局变量(`global`)，但由于进程隔离的原因。假设有`4`个工作进程，在`进程1`中进行`$i++`，实际上只有`进程1`中的`$i`变成`2`了，其他另外`3`个进程内`$i`变量的值还是`1`。

正确的做法是使用`Swoole`提供的`Swoole\Atomic`或`Swoole\Table`数据结构来保存数据。如上述代码可以使用`Swoole\Atomic`实现。

```
$server = new Swoole\Http\Server('127.0.0.1', 9500);

$atomic = new Swoole\Atomic(1);

$server->on('Request', function ($request, $response) use ($atomic) {
    $response->end($atomic->add(1));
});

$server->start();

```

*   `Swoole\Atomic`数据是建立在共享内存之上的，使用`add`方法加`1`时，在其他工作进程内也是有效的

## 11.可捕获的异常/错误

在`PHP`大致有三种类型的可捕获的异常/错误

1.  `Error`：`PHP`内核抛出错误的专用类型, 如类不存在, 函数不存在, 函数参数错误, 都会抛出此类型的错误, `PHP`代码中不应该使用`Error类`来作为异常抛出
2.  `Exception`：应用开发者应该使用的异常基类
3.  `ErrorException`：此异常基类专门负责将`PHP`的`Warning`/`Notice`等信息通过`set_error_handler`转换成异常, PHP未来的规划必然是将所有的`Warning`/`Notice`转为异常, 以便于`PHP`程序能够更好更可控地处理各种错误

> 以上所有类都实现了`Throwable`接口, 也就是说, 通过`try {} catch(Throwable $e) {}` 即可捕获所有可抛出的异常/错误

#### 实例 1

```
try {
    test();
} 
catch(Throwable $e) {
    var_dump($e);
}

```

#### 实例 2

```
try {
    test();
}
catch (Error $e) {
    var_dump($e);
}
catch(Exception $e) {
    var_dump($e);
}

```

### 不可捕获的致命错误和异常

`PHP`错误的一个重要级别, 如异常/错误未捕获时, 内存不足时, 或是一些编译期错误(继承的类不存在), 将会以`E_ERROR`级别抛出一个`Fatal Error`, 是在程序发生不可回溯的错误时才会触发的, `PHP`程序无法捕获这样级别的一种错误, 只能通过`register_shutdown_function`在后续进行一些处理操作。

### 在协程中捕获运行时异常/错误

在`Swoole4`协程编程中，某个协程的代码中抛出错误，会导致整个进程退出，进程所有协程终止执行。在协程顶层空间可以先进行一次`try/catch`捕获异常/错误。仅终止出错的协程。

```
go(function () {
    try {
        call_user_func($func);
    }
    catch (Error $e) {
        var_dump($e);
    }
    catch(Exception $e) {
        var_dump($e);
    }
});

//协程1的错误不影响协程2
go(function () {
    Co::sleep(100);
});
```