# static

> static关键字是在类中描述成员属性和成员方法是静态的

## 静态的成员好处在哪里呢？

前面我们声明了“Person”的人类，在“Person”这个类里如果我们加上一个“人所属国家”的属性，这样用“Person”这个类实例化出几百个或者更多个实例对象，每个对象里面就都有“所属国家”的属性了，如果开发的项目就是为中国人而开发的，那么每个对象里面就都有一个国家的属性是 “中国“其它的属性是不同的，如果我们把“国家”的属性做成静态的成员，这样国家的属性在内存中就只有一个，而让这几百个或更多的对象共用这一个属性，static成员能够限制外部的访问，因为static的成员是属于类的，是不属于任何对象实例，是在类第一次被加载的时候分配的空间，其他类是无法访问的，只对类的实例共享，能一定程度对类该成员形成保护；

从内存的角度我们来分析一下，内存从逻辑上被分为四段，其中对象是放在“堆内存”里面，对象的引用被放到了“栈内存“里，而静态成员则放到了“初始化静态段”，在类第一次被加载的时候放入的，可以让堆内存里面的每个对象所共享。

类的静态变量，非常类似全局变量，能够被所有类的实例共享，类的静态方法也是一样的，类似于全局函数。

```
 <?php

namespace martist;

class Base {
    static $name = 'mart';

    public static function sayName(){
        echo self::$name;
    }

    public static function setName(){
        self::$name = '诗仙李白';
        echo self::$name;
    }

}

echo Base::sayName()."<br>";

$class1 = new Base();
echo $class1::setName()."<br>";

echo Base::sayName()."<br>";

$class2 = new Base();
echo $class2::sayName()."<br>";

```

输出结果为：

```
mart
诗仙李白
诗仙李白
诗仙李白

```

因为静态成员是在类第一次加载的时候就创建的，所以在类的外部不需要对象而使用类名就可以访问的到静态的成员；上面说过，静态成员被这个类的每个实例对象所共享，那么我们使用对象可不可以访问类中的静态成员呢？从上图中我们可以看到，静态的成员不是在每个对象内部存在的，但是每个对象都可以共享，所以我们如果使用对象访问成员的话就会出现没有这个属性定义，使用对象访问不到静态成员的，在其它的面向对象的语言中，比如Java是可以使用对象的方式访问静态成员的，如果PHP中可以使用对象访问静态成员的话，我们也尽量不要去使用，因为静态的成员我们在做项目的时候目的就是使用类名去访问。

### 类的静态方法可不可以访问非静态成员?

> 类里面的静态方法只能访问类的静态的属性，在类里面的静态方法是不能访问类的非静态成员的。

原因很简单，我们要想在本类的方法中访问本类的其它成员，我们需要使用$this这个引用，而$this这个引用指针是代表调用此方法的对象，我们说了静态的方法是不用对象调用的，而是使用类名来访问， 所以根本就没有对象存在，也就没有$this这个引用了，没有了$this这个引用就不能访问类里面的非静态成员，又因为类里面的静态成员是可以不用对象 来访问的，所以类里面的静态方法只能访问类的静态的属性。

### 类的静态方法可不可以访问静态成员，怎么访问？

> 类的静态方法可以访问静态成员，使用“self”来访问其它静态成员，即“self::成员属性”的方式。

```
1	<?
2	class Person
3	{
4	    //下面是人的静态成员属性
5	    public static $myCountry = "中国";
6
7	    //这是人的静态成员方法， 通过self访问其它静态成员
8	    public static function say() {
9	        echo "我是" . self::$myCountry;
10	    }
11	}
12
13	//访问静态方法
14	Person::say();
15	?>

```

### 非静态方法里可不可以访问静态成员?

> 当然也是可以的了，但是也不能使用“$this”引用，也要使用类名或是”self::成员属性的形式”。

# const

> const是一个定义常量的关键字

在PHP中定义常量使用的是“define()”这个函数，但是在类里面定义常量使用的是“const”这个关键字，类似于C中的#define如果在程序中改变了它的值，那么会出现错误，用“const”修饰的成员属性的访问方式和“static”修饰的成员访问的方式差不多，也是使用“类名”，在方法里面使用“self”关键字。但是不用使用“$”符号，也不能使用对象来访问。

```
1	<?php
2	class MyClass
3	{
4	    //定义一个常量constant
5	    const constant = 'constant value';
6
7	    function showConstant() {
8	        echo self::constant . " "; // 使用self访问，不要加“$”
9	    }
10	}
11
12	echo MyClass::constant . " "; //使用类名来访问，也不加“$”
13
14	$class = new MyClass();
15	$class->showConstant();
16	// echo $class::constant;  是不允许的
17	?>
```