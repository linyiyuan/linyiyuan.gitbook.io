{"compress":true,"commitItems":[["0e76fa2d-f5f0-4622-9e0a-e1ba5a76374f",1567064856141,"",[[1567064797290,["sirui-php@DESKTOP-PSVFMK8",[[1,0,"# 工厂模式\n\n\n\n"]],[0,0],[9,9]]],[1567067161596,["sirui-php@DESKTOP-PSVFMK8",[[1,9,"# 工厂模式(Factor Pattern)\n\n> 工厂模式(Factor Pattern)，就是负责生成其他对象的类或方法，也叫工厂方法模式\n\n抽象工厂模式( Abstract Factor Pattern)，可简单理解为工厂模式的升级版\n\n## (一)为什么需要工厂模式\n\n1，工厂模式可以将对象的生产从直接new 一个对象，改成通过调用一个工厂方法生产。这样的封装，代码若需修改new的对象时，不需修改多处new语句，只需更改生产对象方法。\n\n2，若所需实例化的对象可选择来自不同的类，可省略if-else多层判断，给工厂方法传入对应的参数，利用多态性，实例化对应的类。\n\n## （二）工厂模式结构图\n\n1，工厂方法模式\n\n![](https://box.kancloud.cn/9322a9aa63515c732fcfa881d31bc2ee_867x443.png)\n\n2，抽象工厂模式\n\n![](https://box.kancloud.cn/3a6779f6b19e1baad153373863eda548_485x347.png)\n\n（三）简单实现代码\n\n```\n//工厂类\nclass Factor{   \n    //生成对象方法\n    static function createDB(){\n        echo '我生产了一个DB实例';\n        return new DB;\n    }\n}\n\n//数据类\nclass DB{\n    public function __construct(){\n        echo __CLASS__.PHP_EOL;\n    }\n}\n\n$db=Factor::createDB();\n\n```\n\n（四）实现一个运算器\n\n```\n//抽象运算类\nabstract class Operation{\n    abstract public function getVal($i,$j);//抽象方法不能包含方法体\n}\n//加法类\nclass OperationAdd extends Operation{\n    public function getVal($i,$j){\n        return $i+$j;\n    }\n}\n//减法类\nclass OperationSub extends Operation{\n    public function getVal($i,$j){\n        return $i-$j;\n    }\n}\n\n//计数器工厂\nclass CounterFactor {\n    private static $operation;\n    //工厂生产特定类对象方法\n    static function createOperation(string $operation){\n        switch($operation){\n            case '+' : self::$operation = new OperationAdd;\n                break;\n            case '-' : self::$operation = new OperationSub;\n                break;\n        }\n        return self::$operation;\n    }\n}\n\n$counter = CounterFactor::createOperation('+');\necho $counter->getVal(1,2);\n\n```\n\n缺点：若是再增加一个乘法运算，除了增加一个乘法运算类之外，还得去工厂生产方法里面添加对应的case代码，违反了开放-封闭原则。\n\n### 解决方法（1）：通过传入指定类名\n\n```\n//计算器工厂\nclass CounterFactor {\n    //工厂生产特定类对象方法\n    static function createOperation(string $operation){\n        return new $operation;\n    }\n}\nclass OperationMul extends Operation{\n    public function getVal($i,$j){\n        return $i*$j;\n    }\n}\n$counter = CounterFactor::createOperation('OperationMul');\n\n```\n\n### 解决方法（2）：通过抽象工厂模式\n\n这里顺带提一个问题：如果我系统还有个生产一个文本输入器工厂，那么那个工厂和这个计数器工厂又有什么关系呢。\n\n```\n抽象高于实现\n\n```\n\n其实我们完全可以抽象出一个抽象工厂，然后将对应的对象生产交给子工厂实现。代码如下\n\n```\n//抽象运算类\nabstract class Operation{\n    abstract public function getVal($i,$j);//抽象方法不能包含方法体\n}\n//加法类\nclass OperationAdd extends Operation{\n    public function getVal($i,$j){\n        return $i+$j;\n    }\n}\n//乘法类\nclass OperationMul extends Operation{\n    public function getVal($i,$j){\n        return $i*$j;\n    }\n}\n//抽象工厂类\nabstract class Factor{\n    abstract static function getInstance();\n}\n//加法器生产工厂\nclass AddFactor extends Factor {\n    //工厂生产特定类对象方法\n    static function getInstance(){\n        return new OperationAdd;\n    }\n}\n//减法器生产工厂\nclass MulFactor extends Factor {\n    static function getInstance(){\n        return new OperationMul;\n    }\n}\n//文本输入器生产工厂\nclass TextFactor extends Factor{\n    static function getInstance(){}\n}\n$mul = MulFactor::getInstance();\necho $mul->getVal(1,2);\n```"]],[9,9],[2867,2867]]],[1567067163614,["sirui-php@DESKTOP-PSVFMK8",[[-1,0,"# 工厂模式\n\n"]],[1,8],[0,0]]],[1567067165174,["sirui-php@DESKTOP-PSVFMK8",[[-1,0,"\n"]],[1,1],[0,0]]]],null,"sirui-php@DESKTOP-PSVFMK8"]]}