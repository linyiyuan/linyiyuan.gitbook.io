{"compress":true,"commitItems":[["af1c098a-2dff-4950-9b77-638719f5a31c",1565754855004,"",[[1565754843641,["sirui-php@DESKTOP-PSVFMK8",[[1,0,"# static和const关键字\n\n\n\n"]],[0,0],[20,20]]],[1565754849087,["sirui-php@DESKTOP-PSVFMK8",[[1,8,"\n\n> static关键字是在类中描述成员属性"],[1,9,"成员方法是静态的\n\n## 静态的成员好处在哪里呢？\n\n前面我们声明了“Person”的人类，在“Person”这个类里如果我们加上一个“人所属国家”的属性，这样用“Person”这个类实例化出几百个或者更多个实例对象，每个对象里面就都有“所属国家”的属性了，如果开发的项目就是为中国人而开发的，那么每个对象里面就都有一个国家的属性是 “中国“其它的属性是不同的，如果我们把“国家”的属性做成静态的成员，这样国家的属性在内存中就只有一个，而让这几百个或更多的对象共用这一个属性，stati"],[1,10,"成员能够限制外部的访问，因为static的成员是属于类的，是不属于任何对象实例，是在类第一次被加载的时候分配的空间，其他类是无法访问的，只对类的实例共享，能一定程度对类该成员形成保护；\n\n从内存的角度我们来分析一下，内存从逻辑上被分为四段，其中对象是放在“堆内存”里面，对象的引用被放到了“栈内存“里，而静态成员则放到了“初始化静态段”，在类第一次被加载的时候放入的，可以让堆内存里面的每个对象所共享。\n\n类的静态变量，非常类似全局变量，能够被所有类的实例共享，类的静态方法也是一样的，类似于全局函数。\n\n```\n <?php\n\nnamespace martist;\n\nclass Base {\n    static $name = 'mart';\n\n    public static functi"],[1,12," sayName(){\n        echo self::$name;\n    }\n\n    public "],[1,14,"atic function setName(){\n        self::$name = '诗仙李白';\n        echo self::$name;\n    }\n\n}\n\necho Base::sayName().\"<br>\";\n\n$class1 = new Base();\necho $class1::setName().\"<br>\";\n\necho Base::sayName().\"<br>\";\n\n$class2 = new Base();\necho $class2::sayName().\"<br>\";\n\n```\n\n输出结果为：\n\n```\nmart\n诗仙李白\n诗仙李白\n诗仙李白\n\n```\n\n因为静态成员是在类第一次加载的时候就创建的，所以在类的外部不需要对象而使用类名就可以访问的到静态的成员；上面说过，静态成员被这个类的每个实例对象所共享，那么我们使用对象可不可以访问类中的静态成员呢？从上图中我们可以看到，静态的成员不是在每个对象内部存在的，但是每个对象都可以共享，所以我们如果使用对象访问成员的话就会出现没有这个属性定义，使用对象访问不到静态成员的，在其它的面向对象的语言中，比如Java是可以使用对象的方式访问静态成员的，如果PHP中可以使用对象访问静态成员的话，我们也尽量不要去使用，因为静态的成员我们在做项目的时候目的就是使用类名去访问。\n\n### 类的静态方法可不可以访问非静态成员?\n\n> 类里面的静态方法只能访问类的静态的属性，在类里面的静态方法是不能访问类的非静态成员的。\n\n原因很简单，我们要想在本类的方法中访问本类的其它成员，我们需要使用$this这个引用，而$this这个引用指针是代表调用此方法的对象，我们说了静态的方法是不用对象调用的，而是使用类名来访问， 所以根本就没有对象存在，也就没有$this这个引用了，没有了$this这个引用就不能访问类里面的非静态成员，又因为类里面的静态成员是可以不用对象 来访问的，所以类里面的静态方法只能访问类的静态的属性。\n\n### 类的静态方法可不可以访问静态成员，怎么访问？\n\n> 类的静态方法可以访问静态成员，使用“self”来访问其它静态成员，即“self::成员属性”的方式。\n\n```\n1\t<?\n2\tclass Person\n3\t{\n4\t    //下面是人的静态成员属性\n5\t    public static $myCountry = \"中国\";\n6\n7\t    //这是人的静态成员方法， 通过self访问其它静态成员\n8\t    public static function say() {\n9\t        echo \"我是\" . self::$myCountry;\n10\t    }\n11\t}\n12\n13\t//访问静态方法\n14\tPerson::say();\n15\t?>\n\n```\n\n### 非静态方法里可不可以访问静态成员?\n\n> 当然也是可以的了，但是也不能使用“$this”引用，也要使用类名或是”self::成员属性的形式”。\n\n# const\n\n> const是一个定义常量的"],[1,19,"在PHP中定义常量使用的是“define()”这个函数，但是在类里面定义常量使用的是“const”这个关键字，类似于C中的#define如果在程序中改变了它的值，那么会出现错误，用“const”修饰的成员属性的访问方式和“static”修饰的成员访问的方式差不多，也是使用“类名”，在方法里面使用“self”关键字。但是不用使用“$”符号，也不能使用对象来访问。"],[1,21,"```\n1\t<?php\n2\tclass MyClass\n3\t{\n4\t    //定义一个常量constant\n5\t    const constant = 'constant value';\n6\n7\t    function showConstant() {\n8\t        echo self::constant . \" \"; // 使用self访问，不要加“$”\n9\t    }\n10\t}\n11\n12\techo MyClass::constant . \" \"; //使用类名来访问，也不加“$”\n13\n14\t$class = new MyClass();\n15\t$class->showConstant();\n16\t// echo $class::constant;  是不允许的\n17\t?>\n```"]],[0,21],[2526,2526]]]],null,"sirui-php@DESKTOP-PSVFMK8"],["0030fec1-10e7-4ad2-b6b6-e60f1cd611df",1567062814098,"# static\n\n> static关键字是在类中描述成员属性和成员方法是静态的\n\n## 静态的成员好处在哪里呢？\n\n前面我们声明了“Person”的人类，在“Person”这个类里如果我们加上一个“人所属国家”的属性，这样用“Person”这个类实例化出几百个或者更多个实例对象，每个对象里面就都有“所属国家”的属性了，如果开发的项目就是为中国人而开发的，那么每个对象里面就都有一个国家的属性是 “中国“其它的属性是不同的，如果我们把“国家”的属性做成静态的成员，这样国家的属性在内存中就只有一个，而让这几百个或更多的对象共用这一个属性，static成员能够限制外部的访问，因为static的成员是属于类的，是不属于任何对象实例，是在类第一次被加载的时候分配的空间，其他类是无法访问的，只对类的实例共享，能一定程度对类该成员形成保护；\n\n从内存的角度我们来分析一下，内存从逻辑上被分为四段，其中对象是放在“堆内存”里面，对象的引用被放到了“栈内存“里，而静态成员则放到了“初始化静态段”，在类第一次被加载的时候放入的，可以让堆内存里面的每个对象所共享。\n\n类的静态变量，非常类似全局变量，能够被所有类的实例共享，类的静态方法也是一样的，类似于全局函数。\n\n```\n <?php\n\nnamespace martist;\n\nclass Base {\n    static $name = 'mart';\n\n    public static function sayName(){\n        echo self::$name;\n    }\n\n    public static function setName(){\n        self::$name = '诗仙李白';\n        echo self::$name;\n    }\n\n}\n\necho Base::sayName().\"<br>\";\n\n$class1 = new Base();\necho $class1::setName().\"<br>\";\n\necho Base::sayName().\"<br>\";\n\n$class2 = new Base();\necho $class2::sayName().\"<br>\";\n\n```\n\n输出结果为：\n\n```\nmart\n诗仙李白\n诗仙李白\n诗仙李白\n\n```\n\n因为静态成员是在类第一次加载的时候就创建的，所以在类的外部不需要对象而使用类名就可以访问的到静态的成员；上面说过，静态成员被这个类的每个实例对象所共享，那么我们使用对象可不可以访问类中的静态成员呢？从上图中我们可以看到，静态的成员不是在每个对象内部存在的，但是每个对象都可以共享，所以我们如果使用对象访问成员的话就会出现没有这个属性定义，使用对象访问不到静态成员的，在其它的面向对象的语言中，比如Java是可以使用对象的方式访问静态成员的，如果PHP中可以使用对象访问静态成员的话，我们也尽量不要去使用，因为静态的成员我们在做项目的时候目的就是使用类名去访问。\n\n### 类的静态方法可不可以访问非静态成员?\n\n> 类里面的静态方法只能访问类的静态的属性，在类里面的静态方法是不能访问类的非静态成员的。\n\n原因很简单，我们要想在本类的方法中访问本类的其它成员，我们需要使用$this这个引用，而$this这个引用指针是代表调用此方法的对象，我们说了静态的方法是不用对象调用的，而是使用类名来访问， 所以根本就没有对象存在，也就没有$this这个引用了，没有了$this这个引用就不能访问类里面的非静态成员，又因为类里面的静态成员是可以不用对象 来访问的，所以类里面的静态方法只能访问类的静态的属性。\n\n### 类的静态方法可不可以访问静态成员，怎么访问？\n\n> 类的静态方法可以访问静态成员，使用“self”来访问其它静态成员，即“self::成员属性”的方式。\n\n```\n1\t<?\n2\tclass Person\n3\t{\n4\t    //下面是人的静态成员属性\n5\t    public static $myCountry = \"中国\";\n6\n7\t    //这是人的静态成员方法， 通过self访问其它静态成员\n8\t    public static function say() {\n9\t        echo \"我是\" . self::$myCountry;\n10\t    }\n11\t}\n12\n13\t//访问静态方法\n14\tPerson::say();\n15\t?>\n\n```\n\n### 非静态方法里可不可以访问静态成员?\n\n> 当然也是可以的了，但是也不能使用“$this”引用，也要使用类名或是”self::成员属性的形式”。\n\n# const\n\n> const是一个定义常量的关键字\n\n在PHP中定义常量使用的是“define()”这个函数，但是在类里面定义常量使用的是“const”这个关键字，类似于C中的#define如果在程序中改变了它的值，那么会出现错误，用“const”修饰的成员属性的访问方式和“static”修饰的成员访问的方式差不多，也是使用“类名”，在方法里面使用“self”关键字。但是不用使用“$”符号，也不能使用对象来访问。\n\n```\n1\t<?php\n2\tclass MyClass\n3\t{\n4\t    //定义一个常量constant\n5\t    const constant = 'constant value';\n6\n7\t    function showConstant() {\n8\t        echo self::constant . \" \"; // 使用self访问，不要加“$”\n9\t    }\n10\t}\n11\n12\techo MyClass::constant . \" \"; //使用类名来访问，也不加“$”\n13\n14\t$class = new MyClass();\n15\t$class->showConstant();\n16\t// echo $class::constant;  是不允许的\n17\t?>\n```",[[1567062807948,["sirui-php@DESKTOP-PSVFMK8",[[1,532,"php"]],[532,532],[535,535]]],[1567062810475,["sirui-php@DESKTOP-PSVFMK8",[[1,1629,"php"]],[1629,1629],[1632,1632]]],[1567062813803,["sirui-php@DESKTOP-PSVFMK8",[[1,2181,"php"]],[2181,2181],[2184,2184]]]],null,"sirui-php@DESKTOP-PSVFMK8"]]}