{"./":{"url":"./","title":"项目简介","keywords":"","body":"项目简介     欢迎来到Choice→選的开发笔记，最近在整理自己的一些学习笔记，刚好在github看到了这么一个工具，所以拿来总结自己所有的开发笔记以及一些知识点，面试技巧等，希望对你有用 个人信息 个人博客：https://linyiyuan.github.io 个人简历：http://resume.linyiyuan.top 个人简历(PDF版) GitHub地址：https://github.com/linyiyuan 掘金地址：https://juejin.im/user/5c749f1951882561dd7b7e83 知乎地址：https://www.zhihu.com/people/lin-yi-yuan-35-45/activities 微博地址：https://weibo.com/3118916401/ 个人标签 PHP、Laravel 、聚合支付、公众号开发、开源爱好者、Linux、 VueJs、极客 、Mysql CRM系统 Redis Swoole Workman 联系信息 QQ：375133100 微信：13211035441 手机号码：13211035441 邮箱地址：linyiyuann@163.com 安装运行 # git clone 项目地址 # npm install # gitbook init # gitbook install # gitbook serve 关于GitBook的安装和使用 ➡️ https://www.jianshu.com/p/1f78d8018ea7 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-09-07 16:35:56 "},"Summary.html":{"url":"Summary.html","title":"项目导航","keywords":"","body":"Summary Part I - 项目简介 项目简介 项目导航 开源项目 个人简历 个人简历(PDF版) Part II - 开发笔记 PHP 开发笔记 PHP知识 关于Yield的认识（上） 关于Yield的认识（下） PSR规范 PSR-0 PSR-1 PSR-2 PSR-3 PSR-4 OOP知识 构造方法和析构方法 重载新的方法（parent::) static和const关键字 抽象方法和抽象类 接口(interface) 常用的魔术方法 Composer 类的自动加载 Composer简述 Composer概念解析 Composer使用技巧 Composer自动加载原理 Laravel框架 Laravel常见错误指南 Laravel框架给多个视图分配数据 PHP优化配置 PHP-FPM配置详解 PHP设计模式 设计原则 单例模式 工厂模式 建造者模式 原型模式 PHP版本新特性 PHP7.0版本新特性 PHP7.1版本新特性 PHP7.2版本新特性 Mysql开发笔记 Redis开发笔记 Linux开发笔记 算法 开发笔记 LeetCode每日一题 数据结构笔记 队列和栈 Part III - 开发工具 Part IV - 插件素材 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-09-07 16:35:57 "},"php/Readme.html":{"url":"php/Readme.html","title":"PHP 开发笔记","keywords":"","body":"初始化 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-09 20:02:36 "},"php/PHP知识/Readme.html":{"url":"php/PHP知识/Readme.html","title":"PHP知识","keywords":"","body":"Readme Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-09-07 13:34:17 "},"php/PHP知识/Yield生成器的使用（上）.html":{"url":"php/PHP知识/Yield生成器的使用（上）.html","title":"关于Yield的认识（上）","keywords":"","body":"前言 在认识这个强大的神器之前我们先了解几个常见PHP内置函数内存相关常见常数， memory_get_usage(): 返回当前分配给PHP脚本的内存量，单位是字节（byte） memory_get_peak_usage(): 返回内存使用峰值 getrusage():返回CUP使用情况 我们在日常开发中可以使用这些内置函数来调试PHP代码性能。但需要注意的是这几个函数只能在linux系统中使用 在认识以上三个函数之后我们来做一个简单的小测, 我们迭代数组一个1-10000的数组 $start_memory = memory_get_usage(); $numberArr = range(1, 1000); foreach($numberArr as $key) { //echo $key; } $end_memory = memory_get_usage(); echo '运行该迭代数组所耗内存：' . ($end_memory - $start_memory) . 'bytes'; 运行结果： 运行该迭代数组所耗内存：528440 bytes 折算成kb单位就是大概是528kb, 这样一看并没觉得什么，这时候我们继续增大数组范围，我们将范围扩大成1-1000000 运行结果： 运行该迭代数组所耗内存：4198480 bytes 大概是4m左右，这时候还是可以遍历得出来，我们继续增大1-1000000 运行结果： Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 536870920 bytes) in /data/default/index.php on line 11 发现报错了，系统提示内存溢出了 134217728 bytes 大概是134MB, 我们再查看一下PHP配置文件 果不其然，配置文件限制的内存最大值是128 我们执行该程序的内存使用明显超出限制，这时候我们只能修改此配置文件使其限制内存更大些，但是如果遇到超级大的数据量，或者让你去处理一个几个G的Excel文件时，你会发现修改这个配置文件并不能从根本解决问题，配置内存还需要考虑到服务器的内存使用情况等等， 认识Yield 这时候我们就可以使用 Yield 这个强大的神器，下面我们使用Yield 优化我们上面的代码 $start_memory = memory_get_usage(); function yield_range($start, $end) { while( $start 运行一下，让你们感受下 运行该迭代数组所耗内存：320 bytes 我擦，使用内存竟然连1kb都没有，那么，我们来分析一波儿这个神奇的yield_range函数。这个yield关键字到底返回的是什么？我们简单看一下： function yield_range( $start, $end ){ while( $start /* object(Generator)#1 (0) { } */ Generator Yield 返回的是一个叫做Generator（中文名就是生成器）的object对象，该对象是由generators(生成器)返回，不能通过new实例化，而这个生成器是实现了Iterator接口，该接口提供了一下几个方法： abstract public current ( void ) : mixed abstract public key ( void ) : scalar abstract public next ( void ) : void abstract public rewind ( void ) : void abstract public valid ( void ) : bool 而Generator又包含一下几个方法： Generator::current — 返回当前产生的值 Generator::key — 返回当前产生的键 Generator::next — 生成器继续执行 Generator::rewind — 重置迭代器 Generator::send — 向生成器中传入一个值 Generator::throw — 向生成器中抛入一个异常 Generator::valid — 检查迭代器是否被关闭 Generator::__wakeup — 序列化回调 所以，既然实现了Iterator接口（也正是因为如此，这个东西可以使用foreach进行迭代，明白了吧？），所以可以有如下代码： valid() ){ echo $generator->current().PHP_EOL; $generator->next(); } 1 2 3 4 5 6 7 8 9 10 重点来了：这个yield_range函数似乎能够记住它上一次运行到哪儿了，上一次运行的结果是什么，然后紧接着在下一次运行的时候继续从上次终止的地方继续开始。这不是普通的PHP函数可以做得到的！ 我们知道，操作系统在调度进程的时候，会触发一个叫做“进程上下文切换”的概念。比如CPU从进程A调度给进程B了，那么当再次从进程B调度给进程A的时候，当初进程A运行到哪儿了、临时的数据结果是什么都是需要被还原的，不然，一切都要从头，那就要出大问题了。而，这个yield关键字，似乎在用户态（非系统内核级）就可以实现这个概念. 接下来我们来认识一个Generator对象的一个方法 --send send( $generator->current() * 10 ); //执行结果 yield receive : 10 send方法可以修改yield的返回值 , 我们继续修改代码 send( $generator->current() * 10 ); } 结果发现 这是PHP存在的一个Bug, 我们需要注意的是我们在foreach 去使用生成器的send方法，以下是bug的链接，有兴趣的可以去看下 https://bugs.php.net/bug.php?id=76104 https://stackoverflow.com/questions/37817315/how-does-generatorsend-work 引用文章 PHP中的yield（上) 生成器类 Iterator（迭代器）接口 PHP内置函数memory_get_usage()获取内存使用和getrusage()返回CUP使用情况 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-09-07 16:24:19 "},"php/PSR规范/Readme.html":{"url":"php/PSR规范/Readme.html","title":"PSR规范","keywords":"","body":"PHP编码规范 PSR 是 PHP Standard Recommendations 的简写，由PHP FIG组织制定的 PHP 规范，是 PHP 开发的实践标准。 PHP FIG, FIG 是 Framework Interoperability Group（框架可互用性小组）的缩写，由几位开源框架的开发者成立于 2009 年，从那开始也选取了很多其他成员进来（包括但不限于Laravel, Joomla, Drupal, Composer, Phalcon, Slim, Symfony, Zend Framework等），虽然不是「官方」组织，但也代表了大部分的 PHP 社区。 项目的目的在于：通过框架作者或者框架的代表之间讨论，以最低程度的限制，制定一个协作标准，各个框架遵循统一的编码规范，避免各家自行发展的风格阻碍了 PHP 的发展，解决这个程序设计师由来已久的困扰。 目前官方已制定的规范包括以下六份文件： PSR-0 (已弃用) PSR-1 PSR-2 PSR-2补充 PSR-3 PSR-4 2014/04/25 添加PSR-2补充文件以及修改之前版本中的翻译不当与错误。 2014/07/31 添加PSR-4。 参考链接 PSR - 0 PSR - 1 PSR - 2 PSR - 3 PSR - 4 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 15:02:51 "},"php/PSR规范/PSR-0.html":{"url":"php/PSR规范/PSR-0.html","title":"PSR-0","keywords":"","body":"PSR-0 RS-0规范是他们出的第1套规范，主要是制定了一些自动加载标准（Autoloading Standard)。 目前官网已经废弃了这一规范，以psr-4作为替代。如下文 Deprecated - As of 2014-10-21 PSR-0 has been marked as deprecated. PSR-4 is now recommended as an alternative. 大概意思： 不推荐使用 - 在2014年10月21日PSR-0已被标记为过时。PSR-4现在推荐作为替代。 PSR-0强制性要求几点： 一个完全合格的namespace和class必须符合这样的结构：“\\()*” 每个namespace必须有一个顶层的namespace（\"Vendor Name\"提供者名字） 每个namespace可以有多个子namespace 当从文件系统中加载时，每个namespace的分隔符(/)要转换成 DIRECTORY_SEPARATOR(操作系统路径分隔符) 在类名中，每个下划线(_)符号要转换成DIRECTORY_SEPARATOR(操作系统路径分隔符)。在namespace中，下划线(_)符号是没有（特殊）意义的 当从文件系统中载入时，合格的namespace和class一定是以 .php 结尾的 verdor name,namespaces,class名可以由大小写字母组合而成（大小写敏感的） Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 18:49:01 "},"php/PSR规范/PSR-1.html":{"url":"php/PSR规范/PSR-1.html","title":"PSR-1","keywords":"","body":"PSR-1 基本代码规范 本篇规范制定了代码基本元素的相关标准， 以确保共享的PHP代码间具有较高程度的技术互通性。 关键词 “必须”(“MUST”)、“一定不可/一定不能”(“MUST NOT”)、“需要”(“REQUIRED”)、 “将会”(“SHALL”)、“不会”(“SHALL NOT”)、“应该”(“SHOULD”)、“不该”(“SHOULD NOT”)、 “推荐”(“RECOMMENDED”)、“可以”(“MAY”)和”可选“(“OPTIONAL”)的详细描述可参见 RFC 2119 。 1. 概览 PHP代码文件必须以 2. 文件 2.1. PHP标签 PHP代码必须使用 长标签 或 短输出标签； 一定不可使用其它自定义标签。 2.2. 字符编码 PHP代码必须且只可使用不带BOM的UTF-8编码。 2.3. 从属效应（副作用） 一份PHP文件中应该要不就只定义新的声明，如类、函数或常量等不产生从属效应的操作，要不就只有会产生从属效应的逻辑操作，但不该同时具有两者。 “从属效应”(side effects)一词的意思是，仅仅通过包含文件，不直接声明类、 函数和常量等，而执行的逻辑操作。 “从属效应”包含却不仅限于：生成输出、直接的 require 或 include、连接外部服务、修改 ini 配置、抛出错误或异常、修改全局或静态变量、读或写文件等。 以下是一个反例，一份包含声明以及产生从属效应的代码： \\n\"; // 声明函数 functionfoo(){ // 函数主体部分 } 下面是一个范例，一份只包含声明不产生从属效应的代码： 3. 命名空间和类 命名空间以及类的命名必须遵循 PSR-0. 根据规范，每个类都独立为一个文件，且命名空间至少有一个层次：顶级的组织名称（vendor name）。 类的命名必须 遵循 StudlyCaps 大写开头的驼峰命名规范。 PHP 5.3及以后版本的代码必须使用正式的命名空间。 例如： 5.2.x及之前的版本应该使用伪命名空间的写法，约定俗成使用顶级的组织名称（vendor name）如 Vendor_ 为类前缀。 4. 类的常量、属性和方法 此处的“类”指代所有的类、接口以及可复用代码块（traits） 4.1. 常量 类的常量中所有字母都必须大写，词间以下划线分隔。 参照以下代码： 4.2. 属性 类的属性命名可以遵循 大写开头的驼峰式 ($StudlyCaps)、小写开头的驼峰式 ($camelCase) 又或者是 下划线分隔式 ($under_score)，本规范不做强制要求，但无论遵循哪种命名方式，都应该在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。 4.3. 方法 方法名称必须符合 camelCase() 式的小写开头驼峰命名规范。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 18:49:16 "},"php/PSR规范/PSR-2.html":{"url":"php/PSR规范/PSR-2.html","title":"PSR-2","keywords":"","body":"代码风格规范 本篇规范是 PSR-1 基本代码规范的继承与扩展。 本规范希望通过制定一系列规范化PHP代码的规则，以减少在浏览不同作者的代码时，因代码风格的不同而造成不便。 当多名程序员在多个项目中合作时，就需要一个共同的编码规范， 而本文中的风格规范源自于多个不同项目代码风格的共同特性， 因此，本规范的价值在于我们都遵循这个编码风格，而不是在于它本身。 关键词 “必须”(\"MUST\")、“一定不可/一定不能”(\"MUST NOT\")、“需要”(\"REQUIRED\")、 “将会”(\"SHALL\")、“不会”(\"SHALL NOT\")、“应该”(\"SHOULD\")、“不该”(\"SHOULD NOT\")、 “推荐”(\"RECOMMENDED\")、“可以”(\"MAY\")和”可选“(\"OPTIONAL\")的详细描述可参见 RFC 2119 。 1. 概览 代码必须遵循 PSR-1 中的编码规范 。 代码必须使用4个空格符而不是 tab键 进行缩进。 每行的字符数应该软性保持在80个之内， 理论上一定不可多于120个， 但一定不能有硬性限制。 每个 namespace 命名空间声明语句和 use 声明语句块后面，必须插入一个空白行。 类的开始花括号({)必须写在其声明后自成一行，结束花括号(})也必须写在其主体后自成一行。 方法的开始花括号({)必须写在函数声明后自成一行，结束花括号(})也必须写在函数主体后自成一行。 类的属性和方法必须添加访问修饰符（private、protected 以及 public）， abstract 以及 final 必须声明在访问修饰符之前，而 static 必须声明在访问修饰符之后。 控制结构的关键字后必须要有一个空格符，而调用方法或函数时则一定不能有。 控制结构的开始花括号({)必须写在声明的同一行，而结束花括号(})必须写在主体后自成一行。 控制结构的开始左括号后和结束右括号前，都一定不能有空格符。 1.1. 例子 以下例子程序简单地展示了以上大部分规范： $b) { $foo->bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static function bar() { // method body } } 2. 通则 2.1 基本编码准则 代码必须符合 PSR-1 中的所有规范。 2.2 文件 所有PHP文件必须使用Unix LF (linefeed)作为行的结束符。 所有PHP文件必须以一个空白行作为结束。 纯PHP代码文件必须省略最后的 ?> 结束标签。 2.3. 行 行的长度一定不能有硬性的约束。 软性的长度约束一定要限制在120个字符以内，若超过此长度，带代码规范检查的编辑器一定要发出警告，不过一定不可发出错误提示。 每行不应该多于80个字符，大于80字符的行应该折成多行。 非空行后一定不能有多余的空格符。 空行可以使得阅读代码更加方便以及有助于代码的分块。 每行一定不能存在多于一条语句。 2.4. 缩进 代码必须使用4个空格符的缩进，一定不能用 tab键 。 备注: 使用空格而不是tab键缩进的好处在于， 避免在比较代码差异、打补丁、重阅代码以及注释时产生混淆。 并且，使用空格缩进，让对齐变得更方便。 2.5. 关键字 以及 True/False/Null PHP所有 关键字必须全部小写。 常量 true 、false 和 null 也必须全部小写。 3. namespace 以及 use 声明 namespace 声明后 必须 插入一个空白行。 所有 use 必须 在 namespace 后声明。 每条 use 声明语句 必须 只有一个 use 关键词。 use 声明语句块后 必须 要有一个空白行。 例如： 4. 类、属性和方法 此处的“类”泛指所有的class类、接口以及traits可复用代码块。 4.1. 扩展与继承 关键词 extends 和 implements必须写在类名称的同一行。 类的开始花括号必须独占一行，结束花括号也必须在类主体后独占一行。 implements 的继承列表也可以分成多行，这样的话，每个继承接口名称都必须分开独立成行，包括第一个。 4.2. 属性 每个属性都必须添加访问修饰符。 一定不可使用关键字 var 声明一个属性。 每条语句一定不可定义超过一个属性。 不要使用下划线作为前缀，来区分属性是 protected 或 private。 以下是属性声明的一个范例： 4.3. 方法 所有方法都必须添加访问修饰符。 不要使用下划线作为前缀，来区分方法是 protected 或 private。 方法名称后一定不能有空格符，其开始花括号必须独占一行，结束花括号也必须在方法主体后单独成一行。参数左括号后和右括号前一定不能有空格。 一个标准的方法声明可参照以下范例，留意其括号、逗号、空格以及花括号的位置。 4.4. 方法的参数 参数列表中，每个逗号后面必须要有一个空格，而逗号前面一定不能有空格。 有默认值的参数，必须放到参数列表的末尾。 参数列表可以分列成多行，这样，包括第一个参数在内的每个参数都必须单独成行。 拆分成多行的参数列表后，结束括号以及方法开始花括号 必须 写在同一行，中间用一个空格分隔。 4.5. abstract 、 final 、 以及 static 需要添加 abstract 或 final 声明时， 必须写在访问修饰符前，而 static 则必须写在其后。 4.6. 方法及函数调用 方法及函数调用时，方法名或函数名与参数左括号之间一定不能有空格，参数右括号前也 一定不能有空格。每个逗号前一定不能有空格，但其后必须有一个空格。 bar($arg1); Foo::bar($arg2, $arg3); 参数可以分列成多行，此时包括第一个参数在内的每个参数都必须单独成行。 bar( $longArgument, $longerArgument, $muchLongerArgument ); 5. 控制结构 控制结构的基本规范如下： 控制结构关键词后必须有一个空格。 左括号 ( 后一定不能有空格。 右括号 ) 前也一定不能有空格。 右括号 ) 与开始花括号 { 间一定有一个空格。 结构体主体一定要有一次缩进。 结束花括号 } 一定在结构体主体后单独成行。 每个结构体的主体都必须被包含在成对的花括号之中， 这能让结构体更加结构话，以及减少加入新行时，出错的可能性。 5.1. if 、 elseif 和 else 标准的 if 结构如下代码所示，留意 括号、空格以及花括号的位置， 注意 else 和 elseif 都与前面的结束花括号在同一行。 应该使用关键词 elseif 代替所有 else if ，以使得所有的控制关键字都像是单独的一个词。 5.2. switch 和 case 标准的 switch 结构如下代码所示，留意括号、空格以及花括号的位置。 case 语句必须相对 switch 进行一次缩进，而 break 语句以及 case 内的其它语句都 必须 相对 case 进行一次缩进。 如果存在非空的 case 直穿语句，主体里必须有类似 // no break 的注释。 5.3. while 和 do while 一个规范的 while 语句应该如下所示，注意其 括号、空格以及花括号的位置。 标准的 do while 语句如下所示，同样的，注意其 括号、空格以及花括号的位置。 5.4. for 标准的 for 语句如下所示，注意其 括号、空格以及花括号的位置。 5.5. foreach 标准的 foreach 语句如下所示，注意其 括号、空格以及花括号的位置。 $value) { // foreach body } 5.6. try, catch 标准的 try catch 语句如下所示，注意其 括号、空格以及花括号的位置。 6. 闭包 闭包声明时，关键词 function 后以及关键词 use 的前后都必须要有一个空格。 开始花括号必须写在声明的同一行，结束花括号必须紧跟主体结束的下一行。 参数列表和变量列表的左括号后以及右括号前，必须不能有空格。 参数和变量列表中，逗号前必须不能有空格，而逗号后必须要有空格。 闭包中有默认值的参数必须放到列表的后面。 标准的闭包声明语句如下所示，注意其 括号、逗号、空格以及花括号的位置。 参数列表以及变量列表可以分成多行，这样，包括第一个在内的每个参数或变量都必须单独成行，而列表的右括号与闭包的开始花括号必须放在同一行。 以下几个例子，包含了参数和变量列表被分成多行的多情况。 注意，闭包被直接用作函数或方法调用的参数时，以上规则仍然适用。 bar( $arg1, function ($arg2) use ($var1) { // body }, $arg3 ); 7. 总结 以上规范难免有疏忽，其中包括但不仅限于： 全局变量和常量的定义 函数的定义 操作符和赋值 行内对齐 注释和文档描述块 类名的前缀及后缀 最佳实践 本规范之后的修订与扩展将弥补以上不足。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 14:59:45 "},"php/PSR规范/PSR-3.html":{"url":"php/PSR规范/PSR-3.html","title":"PSR-3","keywords":"","body":"PSR-3 日志接口规范 本文制定了日志类库的通用接口规范。 本规范的主要目的，是为了让日志类库以简单通用的方式，通过接收一个 Psr\\Log\\LoggerInterface 对象，来记录日志信息。 框架以及CMS内容管理系统如有需要，可以对此接口进行扩展，但需遵循本规范， 这才能保证在使用第三方的类库文件时，日志接口仍能正常对接。 关键词 “必须”(“MUST”)、“一定不可/一定不能”(“MUST NOT”)、“需要”(“REQUIRED”)、 “将会”(“SHALL”)、“不会”(“SHALL NOT”)、“应该”(“SHOULD”)、“不该”(“SHOULD NOT”)、 “推荐”(“RECOMMENDED”)、“可以”(“MAY”)和”可选“(“OPTIONAL”)的详细描述可参见 RFC 2119 。 本文中的 实现者 指的是实现了 LoggerInterface 接口的类库或者框架，反过来讲，他们就是 LoggerInterface 的 使用者。 1. 规范说明 1.1 基本规范 LoggerInterface 接口对外定义了八个方法，分别用来记录 RFC 5424 中定义的八个等级的日志：debug、 info、 notice、 warning、 error、 critical、 alert 以及 emergency 。 第九个方法 —— log，其第一个参数为记录的等级。可使用一个预先定义的等级常量作为参数来调用此方法，必须与直接调用以上八个方法具有相同的效果。如果传入的等级常量参数没有预先定义，则必须抛出 Psr\\Log\\InvalidArgumentException 类型的异常。在不确定的情况下，使用者不该使用未支持的等级常量来调用此方法。 1.2 记录信息 以上每个方法都接受一个字符串类型或者是有 __toString() 方法的对象作为记录信息参数，这样，实现者就能把它当成字符串来处理，否则实现者必须自己把它转换成字符串。 记录信息参数可以携带占位符，实现者可以根据上下文将其它替换成相应的值。 其中占位符必须与上下文数组中的键名保持一致。 占位符的名称必须由一个左花括号 { 以及一个右括号 } 包含。但花括号与名称之间一定不能有空格符。 占位符的名称应该只由 A-Z、 a-z,0-9、下划线 _、以及英文的句号 .组成，其它字符作为将来占位符规范的保留。 实现者可以通过对占位符采用不同的转义和转换策略，来生成最终的日志。 而使用者在不知道上下文的前提下，不该提前转义占位符。 以下是一个占位符使用的例子： /** * 用上下文信息替换记录信息中的占位符 */ function interpolate($message, array $context = array()){ // 构建一个花括号包含的键名的替换数组 $replace = array(); foreach ($context as $key => $val) { $replace['{' . $key . '}'] = $val; } // 替换记录信息中的占位符，最后返回修改后的记录信息。 return strtr($message, $replace); } // 含有带花括号占位符的记录信息。 $message = \"User {username} created\"; // 带有替换信息的上下文数组，键名为占位符名称，键值为替换值。 $context = array('username' => 'bolivar'); // 输出 \"Username bolivar created\" echo interpolate($message, $context); 1.3 上下文 每个记录函数都接受一个上下文数组参数，用来装载字符串类型无法表示的信息。它可以装载任何信息，所以实现者必须确保能正确处理其装载的信息，对于其装载的数据，一定不能 抛出异常，或产生PHP出错、警告或提醒信息（error、warning、notice）。 如需通过上下文参数传入了一个 Exception 对象， 必须以 'exception' 作为键名。 记录异常信息是很普遍的，所以如果它能够在记录类库的底层实现，就能够让实现者从异常信息中抽丝剥茧。 当然，实现者在使用它时，必须确保键名为 'exception' 的键值是否真的是一个 Exception，毕竟它可以装载任何信息。 1.4 助手类和接口 Psr\\Log\\AbstractLogger 类使得只需继承它和实现其中的 log 方法，就能够很轻易地实现 LoggerInterface 接口，而另外八个方法就能够把记录信息和上下文信息传给它。 同样地，使用 Psr\\Log\\LoggerTrait 也只需实现其中的 log 方法。不过，需要特别注意的是，在traits可复用代码块还不能实现接口前，还需要 implement LoggerInterface。 在没有可用的日志记录器时， Psr\\Log\\NullLogger 接口可以为使用者提供一个备用的日志“黑洞”。不过，当上下文的构建非常消耗资源时，带条件检查的日志记录或许是更好的办法。 Psr\\Log\\LoggerAwareInterface 接口仅包括一个 setLogger(LoggerInterface $logger) 方法，框架可以使用它实现自动连接任意的日志记录实例。 Psr\\Log\\LoggerAwareTrait trait可复用代码块可以在任何的类里面使用，只需通过它提供的 $this->logger，就可以轻松地实现等同的接口。 Psr\\Log\\LogLevel 类装载了八个记录等级常量。 包 上述的接口、类和相关的异常类，以及一系列的实现检测文件，都包含在 psr/log 文件包中。 3. Psr\\Log\\LoggerInterface 4. Psr\\Log\\LoggerAwareInterface 5. Psr\\Log\\LogLevel Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 18:49:52 "},"php/PSR规范/PSR-4.html":{"url":"php/PSR规范/PSR-4.html","title":"PSR-4","keywords":"","body":"自动载入规范 关键词 “必须”(“MUST”)、“一定不可/一定不能”(“MUST NOT”)、“需要”(“REQUIRED”)、 “将会”(“SHALL”)、“不会”(“SHALL NOT”)、“应该”(“SHOULD”)、“不该”(“SHOULD NOT”)、 “推荐”(“RECOMMENDED”)、“可以”(“MAY”)和”可选“(“OPTIONAL”)。 1. 概述 本 PSR 是关于由文件路径 [自动载入][http://tools.ietf.org/html/rfc2119] 对应类的相关规范， 本规范是可互操作的，可以作为任一自动载入规范的补充，其中包括 PSR-0，此外， 本 PSR 还包括自动载入的类对应的文件存放路径规范。 2. 详细说明 此处的“类”泛指所有的class类、接口、traits可复用代码块以及其它类似结构。 一个完整的类名需具有以下结构: \\(\\)*\\ 完整的类名必须要有一个顶级命名空间，被称为 “vendor namespace”； 完整的类名可以有一个或多个子命名空间； 完整的类名必须有一个最终的类名； 完整的类名中任意一部分中的下滑线都是没有特殊含义的； 完整的类名可以由任意大小写字母组成； 所有类名都必须是大小写敏感的。 当根据完整的类名载入相应的文件…… 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为“命名空间前缀”，其必须与至少一个“文件基目录”相对应； 紧接命名空间前缀后的子命名空间必须与相应的”文件基目录“相匹配，其中的命名空间分隔符将作为目录分隔符。 末尾的类名必须与对应的以 .php 为后缀的文件同名。 自动加载器（autoloader）的实现一定不能抛出异常、一定不能触发任一级别的错误信息以及不应该有返回值。 3. 例子 下表展示了符合规范完整类名、命名空间前缀和文件基目录所对应的文件路径。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 18:10:25 "},"php/oop/Readme.html":{"url":"php/oop/Readme.html","title":"OOP知识","keywords":"","body":"Readme Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-13 18:34:27 "},"php/oop/构造方法和析构方法.html":{"url":"php/oop/构造方法和析构方法.html","title":"构造方法和析构方法","keywords":"","body":"构造函数 大多数类都有一种称为构造函数的特殊方法。当创建一个对象时，它将自动调用构造函数，也就是使用new这个关键字来实例化对象的时候自动调用构造方法。构 造函数的声明与其它操作的声明一样，只是其名称必须是construct( )。这是PHP5中的变化，以前的版本中，构造函数的名称必须与类名相同，这种在PHP5中仍然可以用，但现在以经很少有人用了，这样做的好处是可以使构 造函数独立于类名，当类名发生改变时不需要改相应的构造函数名称了。为了向下兼容，如果一个类中没有名为construct( )的方法，PHP将搜索一个php4中的写法，与类名相同名的构造方法。 格式：function __construct ( [参数] ) { … … } 在一个类中只能声明一个构造方法，而是只有在每次创建对象的时候都会去调用一次构造方法，不能主动的调用这个方法，所以通常用它执行一些有用的初始化任务。比如对成属性在创建对象的时候赋初值。 1 name赋初使值 13 $this->name = $name; 14 //通过构造方法传进来的$sex给成员属性$this->sex赋初使值 15 $this->sex = $sex; 16 //通过构造方法传进来的$age给成员属性$this->age赋初使值 17 $this->age = $age; 18 } 19 20 //这个人的说话方法 21 function say() { 22 echo \"我的名子叫：\" . $this->name . \" 性别：\" . $this->sex . \" 我的年龄是：\" . $this->age; 23 } 24 } 25 26 //通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄 27 $p1 = new Person(\"张三\",\"男\", 20); 28 $p2 = new Person(\"李四\",\"女\", 30); 29 $p3 = new Person(\"王五\",\"男\", 40); 30 31 //下面访问$p1对象中的说话方法 32 $p1->say(); 33 //下面访问$p2对象中的说话方法 34 $p2->say(); 35 //下面访问$p3对象中的说话方法 36 $p3->say(); 37 ?> 输出结果为： 我的名子叫：张三 性别：男 我的年龄是：20我的名子叫：李四 性别：女 我的年龄是：30我的名子叫：王五 性别：男 我的年龄是：40 析构函数 与构造函数相对的就是析构函数。析构函数是PHP5新添加的内容，在PHP4中没有析构函数。 析构函数允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件， 释放结果集等，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行，也就是对象在内存中被销毁前调用析构函数。与构造函数的名称类似， 一个类的析构函数名称必须是__destruct( )。析构函数不能带有任何参数。 格式：function __destruct ( ) { … … } 1 name赋初使值 13 $this->name = $name; 14 //通过构造方法传进来的$sex给成员属性$this->sex赋初使值 15 $this->sex = $sex; 16 //通过构造方法传进来的$age给成员属性$this->age赋初使值 17 $this->age = $age; 18 } 19 20 //这个人的说话方法 21 function say() { 22 echo \"我的名子叫：\" . $this->name . \" 性别：\" . $this->sex . \" 我的年龄是：\" . $this->age; 23 } 24 25 //这是一个析构函数,在对象销毁前调用 26 function __destruct() { 27 echo \"再见\" . $this->name; 28 } 29 } 30 31 //通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄 32 $p1 = new Person(\"张三\", \"男\", 20); 33 $p2 = new Person(\"李四\", \"女\", 30); 34 $p3 = new Person(\"王五\", \"男\", 40); 35 36 //下面访问$p1对象中的说话方法 37 $p1->say(); 38 //下面访问$p2对象中的说话方法 39 $p2->say(); 40 //下面访问$p3对象中的说话方法 41 $p3->say(); 42 ?> 输出结果为： 我的名子叫：张三 性别：男 我的年龄是：20我的名子叫：李四 性别：女 我的年龄是：30我的名子叫：王五 性别：男 我的年龄是：40 再见王五 再见李四 再见张三 注意： 由于类实例是以堆栈的形式放在内存中，所以最后调用 析构函数 的时候，输出顺序是按 后进先出 的原则！ Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-29 15:13:18 "},"php/oop/重载新的方法之parent.html":{"url":"php/oop/重载新的方法之parent.html","title":"重载新的方法（parent::)","keywords":"","body":"在学习PHP 这种语言中你会发现， PHP中的方法是不能重载的， 所谓的方法重载就是定义相同的方法名，通过“参数的个数“不同或“参数的类型“不 同,来访问我们的相同方法名的不同方法。但是因为PHP是弱类型的语言， 所以在方法的参数中本身就可以接收不同类型的数据，又因为PHP的方法可以接收不定个数的参数，所以通过传递不同个数的参数调用不相同方法名的不同方法也是不成立的。所以在PHP里面没有方法重载。不能重载也就是在你的项目中不能定义相同方法名的方法。另外，因为PHP没有名子空间的概念，在同一个页面和被包含的页面中不能定义相同名称的方法， 也不能定义和PHP给我提供的方法的方法重名，当然在同一个类中也不能定义相同名称的方法。 我们这里所指的重载新的方法所指的是什么呢？其实我们所说的重载新的方法就是子类覆盖父类的已有的方法，那为什么要这么做呢？父类的方法不是可以继承过 来直接用吗？但有一些情况是我们必须要覆盖的，比如说我们前面提到过的例子里面， “Person”这个人类里面有一个“说话”的方法，所有继承“Person”类的子类都是可以“说话”的， 我们“Student”类就是“Person”类的子类，所以“Student”的实例就可以“说话“了， 但是人类里面“说话”的方法里面说出的是“Person”类里面的属性， 而“Student”类对“Person”类进行了扩展，又扩展出了几个新的属性，如果使用继承过来的“say()”说话方法的话，只能说出从 “Person”类继承过来的那些属性，那么新扩展的那些属性使用这个继承过来的“say()”的方法就说不出来了，那有的人就问了，我在 “Student”这个子类中再定义一个新的方法用于说话，说出子类里面所有的属性不就行了吗？一定不要这么做， 从抽象的角度来讲， 一个“学生”不能有两种“说话”的方法，就算你定义了两个不同的说话的方法，可以实现你想要的功能，被继承过来的那个“说话“方法可能没有机会用到了，而 且是继承过来的你也删不掉。这个时候我们就要用到覆盖了。 虽然说在PHP里面不能定义同名的方法， 但是在父子关系的两个类中，我们可以在子类中定义和父类同名的方法，这样就把父类中继承过来的方法覆盖掉了。 1 name = $name; 13 $this->sex = $sex; 14 $this->age = $age; 15 } 16 17 //这个人可以说话的方法, 说出自己的属性 18 function say() { 19 echo \"我的名子叫：\" . $this->name . \" 性别：\" . $this->sex . \" 我的年龄是：\" . $this->age; 20 } 21 } 22 23 class Student extends Person 24 { 25 26 var $school; //学生所在学校的属性 27 28 //这个学生学习的方法 29 function study() { 30 echo \"我的名子叫：\" . $this->name . \" 我正在\" . $this->school . \" 学习\"; 31 } 32 33 //这个学性可以说话的方法, 说出自己所有的属性，覆盖了父类的同名方法 34 function say() { 35 echo \"我的名子叫：\" . $this->name . \" 性别：\" . $this->sex . \" 我的年龄是：\" . $this->age . \" 我在\" . $this->school . \"上学\"; 36 } 37 } 38 ?> 上面的例子， 我们就在“Student”子类里覆盖了继承父类里面的”say()”的方法，通过覆盖我们就实现了对“方法”扩展。但是，像这样 做虽然解决了我们上面说的问题，但是在实际开发中，一个方法不可能就一条代码或是几条代码，比如说“Person”类里面的“say()”方法有里面有 100条代码，如果我们想对这个方法覆盖保留原有的功能外加上一点点功能，就要把原有的100条代码重写一次， 再加上扩展的几条代码，这还算是好的，而有的情况，父类中的方法是看不见原代码的，这个时候你怎么去重写原有的代码呢？我们也有解决的办法，就是在子类这 个方法中可以调用到父类中被覆盖的方法， 也就是把被覆盖的方法原有的功能拿过来再加上自己的一点功能，可以通过两种方法实现在子类的方法中调用父类被覆盖的方法： 一种是使用父类的“类名::“来调用父类中被覆盖的方法； 一种是使用“parent::”的方试来调用父类中被覆盖的方法； 1 class Student extends Person 2 { 3 var $school; //学生所在学校的属性 4 5 //这个学生学习的方法 6 function study() { 7 echo \"我的名子叫：\" . $this->name . \" 我正在\" . $this->school . \"学习\"; 8 } 9 10 //这个学性可以说话的方法, 说出自己所有的属性，覆盖了父类的同名方法 11 function say() { 12 13 //使用父类的\"类名::\"来调用父类中被覆盖的方法； 14 // Person::say(); 15 16 //或者使用\"parent::\"的方试来调用父类中被覆盖的方法； 17 parent::say(); 18 19 //加上一点自己的功能 20 echo \"我的年龄是：\" . $this->age . \" 我在\" . $this->school . \"上学\"; 21 } 22 } 现在用两种方式都可以访问到父类中被覆盖的方法，我们选那种方式最好呢？用户可能会发现自己写的代码访问了父类的变量和函数。如果子类非常精炼或者父类非 常专业化的时候尤其是这样。 不要用代码中父类文字上的名字，应该用特殊的名字 parent，它指的就是子类在 extends 声明中所指的父类的名字。这样做可以避免在多个地方使用父类的名字。如果继承树在实现的过程中要修改，只要简单地修改类中 extends 声明的部分。 同样，构造方法在子类中如果没有声明的话，也可以使用父类中的构造方法，如果子类中重新定义了一个构造方法也会覆盖掉父类中的构造方法，如果想使用新的构造方法为所有属性赋值也可以用同样的方式。 1 class Student extends Person 2 { 3 var $school; //学生所在学校的属性 4 5 function __construct($name, $sex, $age, $school) { 6 //使用父类中的方法为原有的属性赋值 7 parent::__construct($name, $sex, $age); 8 $this->school = $school; 9 } 10 11 //这个学生学习的方法 12 function study() { 13 echo \"我的名子叫：\" . $this->name . \" 我正在\" . $this->school . \" 学习\"; 14 } 15 16 //这个人可以说话的方法, 说出自己的属性 17 function say() { 18 parent::say(); 19 //加上一点自己的功能 20 echo \"我的年龄是：\" . $this->age . \" 我在\" . $this->school . \"上学\"; 21 } Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-14 11:19:57 "},"php/oop/static和const关键字.html":{"url":"php/oop/static和const关键字.html","title":"static和const关键字","keywords":"","body":"static static关键字是在类中描述成员属性和成员方法是静态的 静态的成员好处在哪里呢？ 前面我们声明了“Person”的人类，在“Person”这个类里如果我们加上一个“人所属国家”的属性，这样用“Person”这个类实例化出几百个或者更多个实例对象，每个对象里面就都有“所属国家”的属性了，如果开发的项目就是为中国人而开发的，那么每个对象里面就都有一个国家的属性是 “中国“其它的属性是不同的，如果我们把“国家”的属性做成静态的成员，这样国家的属性在内存中就只有一个，而让这几百个或更多的对象共用这一个属性，static成员能够限制外部的访问，因为static的成员是属于类的，是不属于任何对象实例，是在类第一次被加载的时候分配的空间，其他类是无法访问的，只对类的实例共享，能一定程度对类该成员形成保护； 从内存的角度我们来分析一下，内存从逻辑上被分为四段，其中对象是放在“堆内存”里面，对象的引用被放到了“栈内存“里，而静态成员则放到了“初始化静态段”，在类第一次被加载的时候放入的，可以让堆内存里面的每个对象所共享。 类的静态变量，非常类似全局变量，能够被所有类的实例共享，类的静态方法也是一样的，类似于全局函数。 \"; $class1 = new Base(); echo $class1::setName().\"\"; echo Base::sayName().\"\"; $class2 = new Base(); echo $class2::sayName().\"\"; 输出结果为： mart 诗仙李白 诗仙李白 诗仙李白 因为静态成员是在类第一次加载的时候就创建的，所以在类的外部不需要对象而使用类名就可以访问的到静态的成员；上面说过，静态成员被这个类的每个实例对象所共享，那么我们使用对象可不可以访问类中的静态成员呢？从上图中我们可以看到，静态的成员不是在每个对象内部存在的，但是每个对象都可以共享，所以我们如果使用对象访问成员的话就会出现没有这个属性定义，使用对象访问不到静态成员的，在其它的面向对象的语言中，比如Java是可以使用对象的方式访问静态成员的，如果PHP中可以使用对象访问静态成员的话，我们也尽量不要去使用，因为静态的成员我们在做项目的时候目的就是使用类名去访问。 类的静态方法可不可以访问非静态成员? 类里面的静态方法只能访问类的静态的属性，在类里面的静态方法是不能访问类的非静态成员的。 原因很简单，我们要想在本类的方法中访问本类的其它成员，我们需要使用$this这个引用，而$this这个引用指针是代表调用此方法的对象，我们说了静态的方法是不用对象调用的，而是使用类名来访问， 所以根本就没有对象存在，也就没有$this这个引用了，没有了$this这个引用就不能访问类里面的非静态成员，又因为类里面的静态成员是可以不用对象 来访问的，所以类里面的静态方法只能访问类的静态的属性。 类的静态方法可不可以访问静态成员，怎么访问？ 类的静态方法可以访问静态成员，使用“self”来访问其它静态成员，即“self::成员属性”的方式。 1 非静态方法里可不可以访问静态成员? 当然也是可以的了，但是也不能使用“$this”引用，也要使用类名或是”self::成员属性的形式”。 const const是一个定义常量的关键字 在PHP中定义常量使用的是“define()”这个函数，但是在类里面定义常量使用的是“const”这个关键字，类似于C中的#define如果在程序中改变了它的值，那么会出现错误，用“const”修饰的成员属性的访问方式和“static”修饰的成员访问的方式差不多，也是使用“类名”，在方法里面使用“self”关键字。但是不用使用“$”符号，也不能使用对象来访问。 1 showConstant(); 16 // echo $class::constant; 是不允许的 17 ?> Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-29 15:13:34 "},"php/oop/抽象方法和抽象类.html":{"url":"php/oop/抽象方法和抽象类.html","title":"抽象方法和抽象类","keywords":"","body":"抽象方法和抽象类 在OOP语言中，一个类可以有一个或多个子类，而每个类都有至少一个公有方法做为外部代码访问其的接口。而抽象方法就是为了方便继承而引入的，我们先来看一下抽象类和抽象方法的定义再说明它的用途。 什么是抽象方法？我们在类里面定义的没有方法体的方法就是抽象方法，所谓的没有方法体指的是，在方法声明的时候没有大括号以及其中的内容，而是直接在声明时在方法名后加上分号结束，另外在声明抽象方法时还要加一个关键字“abstract”来修饰； 例如： 1 abstract function fun1(); 2 abstract function fun2(); 上例是就是“abstract”修饰的没有方法体的抽象方法“fun1()”和“fun2()”，不要忘记抽象方法后面还要有一个分号；那么什么是抽象类呢？只要一个类里面有一个方法是抽象方法，那么这个类就要定义为抽象类，抽象类也要使用“abstract”关键字来修饰；在抽象类里面可以有不是抽象的方法和成员属性，但只要有一个方法是抽象的方法，这个类就必须声明为抽象类，使用”abstract”来修饰。 例如： 1 abstract class Demo 2 { 3 4 var $test; 5 6 abstract function fun1(); 7 abstract function fun2(); 8 9 function fun3(){ 10 ... 11 } 12 } 上例中定义了一个抽象类“Demo”使用了”abstract”来修饰， 在这个类里面定义了一个成员属性“$test”，和两个抽象方法“fun1”和“fun2”，还有一个非抽象的方法fun3()；那么抽象类我们怎么使用呢？最重要的一点就是抽象类不能产生实例对象， 所以也不能直接使用，前面我们多次提到过类不能直接使用，我们使用的是通过类实例化出来的对象，那么抽象类不能产生实例对象我们声明抽象类有什么用呢？我们是将抽象方法是做为子类重载的模板使用的，定义抽象类就相当于定义了一种规范，这种规范要求子类去遵守，子类继承抽象类之后，把抽象类里面的抽象方法按 照子类的需要实现。子类必须把父类中的抽象方法全部都实现，否则子类中还存在抽象方法，那么子类还是抽象类，还是不能实例化类；为什么我们非要从抽象类中继承呢？因为有的时候我们要实现一些功能就必须从抽象类中继承，否则这些功能你就实现不了，如果继承了抽象类，就要实现类其中的抽象方法； 1 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-29 15:13:41 "},"php/oop/接口.html":{"url":"php/oop/接口.html","title":"接口(interface)","keywords":"","body":"PHP与大多数面向对象编程语言一样，不支持多重继承。也就是说每个类只能继承一个父类。为了解决这个问题，PHP引入了接口，接口的思想是指定了一个实现了该接口的类必须实现的一系列方法。接口是一种特殊的抽象类，抽象类又是一种特殊的类，所以接口也是一种特殊的类，为 什么说接口是一种特殊的抽象类呢？如果一个抽象类里面的所有的方法都是抽象方法，那么我们就换一种声明方法使用“接口”；也就是说接口里面所有的方法必须 都是声明为抽象方法，另外接口里面不能声明变量(但可声明常量constant)，而且接口里面所有的成员都是public权限的。所以子类在实现的时候 也一定要使用public权限实限。 声明一个类的时候我们使用的关键字是“class”，而接口一种特殊的类，使用的关键字是“interface”; 类的定义： class 类名{ … } ， 接口的声明： interface 接口名{ …} 举例： 1 上例中定义了一个接口“one”，里面声明了两个抽象方法“fun1”和”fun2”，因为接口里面所有的方法都是抽象方法，所以在声明抽象方法的时候就不用像抽象类那样使用“abstract”这个关键字了，默认的已经加上这个关键字，另外在接口里边的”public”这个访问权限也可以去掉，因 为默认就是public的，因为接口里所有成员都要是公有的，所在对于接口里面的成员我们就不能使用“private”的和“protected”的权限 了，都要用public或是默认的。另外在接口里面我们也声明了一个常量“constant“， 因为在接口里面不能用变量成员，所以我们要使用 const这个关键字声明。 因为接口是一种特殊的抽象类，里面所有的方法都是抽象方法，所以接口也不能产生实例对象; 它也做为一种规范，所有抽象方法需要子类去实现。 我们可以使用”extends”关键字让一个接口去继承另一个接口： 1 而我们定义一接口的子类去实现接口中全部抽象方法使用的关键字是“implements”，而不是我们前面所说的“extends”; 1 我们也可以使用抽象类，去实现接口中的部分抽象方法，但要想实例化对象，这个抽象类还要有子类把它所有的抽象方法都实现才行； 在前面我们说过，PHP是单继承的，一个类只能有一父类，但是一个类可以实现多个接口，就相当于一个类要遵守多个规范，就像我们不仅要遵守国家的法律，如果是在学校的话，还要遵守学校的校规一样； 1 PHP中不仅一个类可以实现多个接口，也可以在继承一个类的同时实现多个接口, 一定要先继承类再去实现接口； 1 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-14 12:05:34 "},"php/oop/常用的魔术方法.html":{"url":"php/oop/常用的魔术方法.html","title":"常用的魔术方法","keywords":"","body":"常用的魔术方法 get() 和 set() ==初衷==：一般来说，总是把类的属性定义为private，这更符合现实的逻辑，因为把类的属性定义成private 外面就无法修复其值，保证了属性的安全性，这样属性就不会随意的被赋值上任何非法的值了，但是， 对属性的读取和赋值操作是非常频繁的，因此在PHP5中，预定义了两个函数”get()”和”set()”来获取和赋值其属性，这时候有人就会问了，为什么一定要把属性定义成private 又要有get() 和 set() 直接定义成public 不行吗，小编这里给出以下几点解释 了不让其示例对象直接通过 对象.属性名 来使用和修改，而是通过set属性名,更安全，这样属性就不会随意的被赋值上任何非法的值了，可以在set属性名的方法中进行控制 假设有很多等级的用户呢？只让其中某一种人有权访问，_get 里就可以做身份验证 你也许会天真的以为你自己写的东西我自己难道不知道嘛，那你就错了，很多时候你写的东西是要给很多人用的，或者你要用别人实现的很多东西。 __get()方法 这个方法用来获取私有成员属性值的，有一个参数， 参数传入你要获取的成员属性的名称，返回获取的属性值， 这个方法不用我们手工的去调用， 是在直接获取私有属性的时候自动调用的。因为私有属性已经被封装上了，是不能直接获取值的（比如：”echo $p1->name” 这样直接获取是错误的），但是如果你在类里面加上了这个方法，在使用”echo $p1->name” 这样的语句直接获取值的时候就会自动调用__get($property_name)方法，将属性name传给参数$property_name，通过这 个方法的内部执行，返回我们传入的私有属性的值。 __set()方法 这个方法用来为私有成员属性设置值的， 有两个参数，第一个参数为你要为设置值的属性名，第二个参数是要给属性设置的值，没有返回值。这个方法同样不用我们手工去调用，是在直接设置私有属性值的 时候自动调用的，同样属性私有的已经被封装上了， 如果没有set()这个方法，是不允许的， 比如：”$this->name=’zhangsan’，这样会出错，但是如果你在类里面加上了set($property_name, $value)这个方法，在直接给私有属性赋值的时候，就会自动调用它，把属性比如name传给$property_name， 把要赋的值”zhangsan”传给$value，通过这个方法的执行，达到赋值的目的， 为了不传入非法的值， 还可以在这个方法给做一下判断。代码如下： 1 \"; 13 if (isset($this->$property_name)) 14 { 15 return ($this->$property_name); 16 } 17 else 18 { 19 return NULL; 20 } 21 } 22 23 //__set()方法用来设置私有属性 24 function __set($property_name, $value) 25 { 26 echo \"在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值\"; 27 $this->$property_name = $value; 28 } 29 } 30 31 $p1 = new Person(); 32 33 // 直接为私有属性赋值的操作， 会自动调用__set()方法进行赋值 34 $p1->name = \"张三\"; 35 $p1->sex = \"男\"; 36 $p1->age = 20; 37 38 // 直接获取私有属性的值， 会自动调用__get()方法，返回成员属性的值 39 echo \"姓名：\" . $p1->name . \"\"; 40 echo \"性别：\" . $p1->sex . \"\"; 41 echo \"年龄：\" . $p1->age . \"\"; 42 ?> 程序执行结果： 在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值 在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值 在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值 在直接获取私有属性值的时候，自动调用了这个__get()方法 姓名：张三 在直接获取私有属性值的时候，自动调用了这个__get()方法 性别：男 在直接获取私有属性值的时候，自动调用了这个__get()方法 年龄：20 以上代码如果不加上get()和set()方法，程序就会出错，因为不能在类的外部操作私有成员，而上面的代码是通过自动调用get()和set()方法来帮助我们直接存取封装的私有成员的。 isset() 方法 和 unset() __isset() 方法 在看这个方法之前我们看一下“isset()”函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。那么如果在一个对象外面使用“isset()”这个函数去测定对象里面的成员是否被设定可不可以用它呢？分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用“isset()”函数来测定私有成员属性是否被设定了呢？可以，你只要在类里面加上一个“isset()”方法就可以了，当在类外部使用”isset()”函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的“isset()”方法了帮我们完成这样的操作，“__isset()”方法也可以做成私有的。你可以在类里面加上下面这样的代码就可以了： 1 private function __isset($nm) 2 { 3 echo \"当在类外部使用isset()函数测定私有成员$nm时，自动调用\"; 4 5 return isset($this->$nm); 6 } __unset()方法 看这个方法之前呢，我们也先来看一下“unset()”这个函数，“unset()”这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。那么如果在一个对象外部去删除对象内部的成员属性用“unset()”函数可不可以呢，也是分两种情况，如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性，如果对象的成员属性是私有的，我使用这个函数就没有权限去删除，但同样如果你在一个对象里面加上“unset()”这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了“unset()”这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，自动调用“__unset()”函数来帮我们删除对象内部的私有成员属性，这个方法也可以在类的内部定义成私有的。在对象里面加上下面的代码就可以了： 1 private function __unset($nm) 2 { 3 echo \"当在类外部使用unset()函数来删除私有成员时自动调用的\"; 4 unset($this->$nm); 5 } 我们来看一个完整的实例： 1 $property_name)) 13 { 14 return ($this->$property_name); 15 } 16 else 17 { 18 return NULL; 19 } 20 } 21 22 // __set()方法用来设置私有属性 23 private function __set($property_name, $value) 24 { 25 $this->$property_name = $value; 26 } 27 28 // __isset()方法 29 private function __isset($nm) 30 { 31 echo \"isset()函数测定私有成员时，自动调用\"; 32 return isset($this->$nm); 33 } 34 35 //__unset()方法 36 private function __unset($nm) 37 { 38 echo \"当在类外部使用unset()函数来删除私有成员时自动调用的\"; 39 unset($this->$nm); 40 } 41 } 42 43 $p1 = new Person(); 44 $p1->name = \"this is a person name\"; 45 46 // 在使用isset()函数测定私有成员时，自动调用__isset()方法帮我们完成，返回结果为true 47 echo var_dump(isset($p1->name)) . \"\"; 48 echo $p1->name . \"\"; 49 50 // 在使用unset()函数删除私有成员时，自动调用__unset()方法帮我们完成，删除name私有属性 51 unset($p1->name); 52 53 // 已经被删除了，所这行不会有输出 54 echo $p1->name; 55 ?> 输出结果为： isset()函数测定私有成员时，自动调用 boolean true this is a person name 当在类外部使用unset()函数来删除私有成员时自动调用的 isset()函数测定私有成员时，自动调用 __toString()方法 我们前面说过在类里面声明“”开始的方法名的方法（PHP给我们提供的），都是在某一时刻不同情况下自动调用执行的方 法。 “toString()”方法也是一样自动被调用的，是在直接输出对象引用时自动调用的， 前面我们讲过对象引用是一个指针，比如 说：“$p=new Person()“中，$p就是一个引用，我们不能使用echo 直接输出$p，这样会输 出 Catchable fatal error: Object of class Person could not be converted to string这样的错误。 如果你在类里面定义了“toString()”方法，在直接输出对象引用的时候，就不会产生错误，而是自动调用 了”toString()”方法， 输出“toString()”方法中返回的字符，所以“toString()”方法一定要有个返回值（return 语句）。 1 foo = $foo; 9 } 10 11 //定义一个__toString方法，返加一个成员属性$foo 12 public function __toString() { 13 return $this->foo; 14 } 15 } 16 17 $class = new TestClass('Hello'); 18 19 //直接输出对象 20 echo $class; 21 ?> 上例输出： Hello __clone() 有的时候我们需要在一个项目里面，使用两个或多个一样的对象，如果你使用“new”关键字重新创建对象的话，再赋值上相同的属性，这样做比较烦琐而且也容易出错，所以要根据一个对象完全克隆出一个一模一样的对象，是非常有必要的，而且克隆以后，两个对象互不干扰。 在PHP中我们使用“clone”这个关键字克隆对象； 1 name=$name; 12 $this->sex=$sex; 13 $this->age=$age; 14 } 15 16 //这个人可以说话的方法，说出自己的属性 17 function say() { 18 echo \"我的名子叫：\" . $this->name . \" 性别：\" . $this->sex . \" 我的年龄是：\" . $this->age . \"\"; 19 } 20 } 21 22 $p1 = new Person(\"张三\", \"男\", 20); 23 24 //使用“clone”克隆新对象p2，和p1对象具有相同的属性和方法。 25 $p2=clone $p1; 26 $p2->say(); 27 ?> PHP定义了一个特殊的方法名“clone()”方法，是在对象克隆时自动调用的方法，用“clone()”方法将建立一个与原对象拥有相同属 性和方法的对象，如果想在克隆后改变原对象的内容，需要在clone()中重写原本的属性和方法， “clone()”方法可以没有参数，它自 动包含$this和$that两个指针，$this指向复本，而$that指向原本； 1 name=$name; 12 $this->sex=$sex; 13 $this->age=$age; 14 } 15 16 //这个人可以说话的方法, 说出自己的属性 17 function say() { 18 echo \"我的名子叫：\" . $this->name . \" 性别：\" . $this->sex . \" 我的年龄是：\" . $this->age . \"\"; 19 } 20 21 //对象克隆时自动调用的方法, 如果想在克隆后改变原对象的内容，需要在__clone()中重写原本的属性和方法 22 function __clone() { 23 24 //$this指的复本p2, 而$that是指向原本p1，这样就在本方法里，改变了复本的属性。 25 $this->name = \"我是假的 $that->name\"; 26 $this->age = 30; 27 } 28 29 } 30 31 $p1 = new Person(\"张三\", \"男\", 20); 32 $p2 = clone $p1; 33 $p1->say(); 34 $p2->say(); 35 ?> 上例输出： 我的名子叫：张三 性别：男 我的年龄是：20 我的名子叫：我是假的张三 性别：男 我的年龄是：30 __call()处理调用错误 在程序开发中，如果在使用对象调用对象内部方法时候，调用的这个方法不存在那么程序就会出错，然后程序退出不能继续执行。那么可不可以在程序调用对象内部 不存在的方法时，提示我们调用的方法及使用的参数不存在，但程序还可以继续执行，这个时候我们就要使用在调用不存在的方法时自动调用的方 法“__call()”。 1 demo(\"one\", \"two\", \"three\"); 13 14 //程序不会执行到这里 15 echo \"this is a test\"; 16 ?> 上例出现如下错误，程序通出不能继续执行 1 Fatal error: Call to undefined method Test::demo() 下面我们加上“call()”方法，这个方法有2个参数，第一个参数为调用不存在的方法过程中，自动调用call()方法时，把这个不存在的方法的方法名传给第一个参数，第二个参数则是把这个方法的多个参数以数组的形式传进来。 1 11 \"; 12 } 13 } 14 15 //产生一个Test类的对象 16 $test=new Test(); 17 18 //调用对象里不存在的方法 19 $test->demo(\"one\", \"two\", \"three\"); 20 21 //程序不会退出可以执行到这里 22 echo \"this is a test\"; 23 ?> 上例输出结果为： 你所调用的函数： demo(参数：Array ( [0] => one [1] => two [2] => three ) )不存在！ this is a test Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-14 11:17:30 "},"php/composer/Readme.html":{"url":"php/composer/Readme.html","title":"Composer","keywords":"","body":"Readmd.md Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 11:27:46 "},"php/composer/类的自动加载.html":{"url":"php/composer/类的自动加载.html","title":"类的自动加载","keywords":"","body":"起源 很多开发者写面向对象的应用程序时，对每个类的定义建立一个 PHP 源文件。一个很大的烦恼是不得不在每个脚本（每个类一个文件）开头写一个长长的包含文件的列表。 在软件开发的系统中，不可能把所有的类都写在一个PHP文件中，当在一个PHP文件中需要调用另一个文件中声明的类时，就需要通过include把 这个文件引入。不过有的时候，在文件众多的项目中，要一一将所需类的文件都include进来，是一个很让人头疼的事，所以我们能不能在用到什么类的时 候，再把这个类所在的php文件导入呢？这就是我们这里我们要讲的自动加载类。 __autoload() 在 PHP 5 中，可以定义一个 autoload()函数，它会在试图使用尚未被定义的类时自动调 用，通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类， autoload()函数接收的一个参数，就是你想加载的类的 类名，所以你做项目时，在组织定义类的文件名时，需要按照一定的规则，最好以类名为中心，也可以加上统一的前缀或后缀形成文件名，比如 xxx_classname.php、classname_xxx.php以及就是classname.php等等。 本例尝试分别从 MyClass1.php 和 MyClass2.php 文件中加载 MyClass1 和 MyClass2 类 1 spl_autoload_register 尽管 autoload() 函数也能自动加载类和接口, 但是更建议使用 spl_autoload_register() 函数，因为它提供了一种更加灵活的方式来实现类的自动加载(同一个应用中 可以支持任意数量的加载器, 比如第三方库) 因此，不再建议使用 `autoload()` 函数, 在以后的版本中它可能被弃用 doPrint();?> 将autoload换成loadprint函数。但是loadprint不会像autoload自动触发，这时spl_autoload_register()就起作用了，它告诉PHP碰到没有定义的类就执行loadprint()。 spl_autoload_register() 调用静态方法 doPrint();?> 如果同时用spl_autoload_register注册了一个类的方法和__autoload函数，那么，会根据注册的先后，如果在第一个注册的方法或函数里加载了类文件，就不会再执行第二个被注册的类的方法或函数。反之就会执行第二个被注册的类的方法或函数。 注意 : 如果你的电脑大小写敏感，调用spl_autoload_register方法需要注意，他会把类名自动变为小写的。你的文件名称应该是全部小写的才行。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 14:29:56 "},"php/composer/Composer简述.html":{"url":"php/composer/Composer简述.html","title":"Composer简述","keywords":"","body":"简述 Composer 不是一个包管理器。是的，它涉及 \"packages\" 和 \"libraries\"，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理。 这种想法并不新鲜，Composer 受到了 node's npm 和 ruby's bundler的强烈启发。而当时 PHP 下并没有类似的工具。 Composer 将这样为你解决问题： 你有一个项目依赖于若干个库。 其中一些库依赖于其他库。 你声明你所依赖的东西。 Composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。 声明依赖关系 比方说，你正在创建一个项目，你需要一个库来做日志记录。你决定使用 monolog。为了将它添加到你的项目中，你所需要做的就是创建一个 composer.json 文件，其中描述了项目的依赖关系。 { \"require\": { \"monolog/monolog\": \"1.2.*\" } } 我们只要指出我们的项目需要一些 monolog/monolog 的包，从 1.2 开始的任何版本。 系统要求 运行 Composer 需要 PHP 5.3.2+ 以上版本。一些敏感的 PHP 设置和编译标志也是必须的，但对于任何不兼容项安装程序都会抛出警告。 我们将从包的来源直接安装，而不是简单的下载 zip 文件，你需要 git 、 svn 或者 hg ，这取决于你载入的包所使用的版本管理系统。 Composer 是多平台的，我们努力使它在 Windows 、 Linux 以及 OSX 平台上运行的同样出色。 安装 全局安装【推荐】 linux 你可以将此文件放在任何地方。如果你把它放在系统的 PATH 目录中，你就能在全局访问它。 在类Unix系统中，你甚至可以在使用时不加 php 前缀。 你可以执行这些命令让 composer 在你的系统中进行全局调用： curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer 注意： 如果上诉命令因为权限执行失败， 请使用 sudo 再次尝试运行 mv 那行命令。 现在只需要运行 composer 命令就可以使用 Composer 而不需要输入 php composer.phar。 OSX Composer 是 homebrew-php 项目的一部分。 brew update brew tap josegonzalez/homebrew-php brew tap homebrew/versions brew install php55-intl brew install josegonzalez/php/composer Windows 下载并且运行 Composer-Setup.exe，它将安装最新版本的 Composer ，并设置好系统的环境变量，因此你可以在任何目录下直接使用 composer 命令。 使用 继续 上面的例子，composer.json文件已经申明了依赖关系，此时运行： composer install 这里将下载 monolog 到 vendor/monolog/monolog 目录。 自动加载 除了库的下载，Composer 还准备了一个自动加载文件，它可以加载 Composer 下载的库中所有的类文件。使用它，你只需要将下面这行代码添加到你项目的引导文件中： require 'vendor/autoload.php'; 通常你会从所使用框架的单入口文件index.php很快找到这行代码，现在我们就可以使用 monolog 了！ Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 11:28:37 "},"php/composer/Composer概念解析.html":{"url":"php/composer/Composer概念解析.html","title":"Composer概念解析","keywords":"","body":"packagist packagist 是 Composer 的主要资源库。 一个 Composer 的库基本上是一个包的源：记录了可以得到包的地方。Packagist 的目标是成为大家使用库资源的中央存储平台。这意味着你可以 require 那里的任何包。 当你访问 packagist website (packagist.org)，你可以浏览和搜索资源包。 composer.json 文件和vendor目录 项目中使用 Composer获取的组件，只需要一个 composer.json文件生命依赖关系就可以了。该文件包含了项目的依赖和其它的一些元数据。 vendor目录下存放拉下来的composer组件包。 关于require Key 第一件事情（并且往往只需要做这一件事），你需要在composer.json文件中指定 require key 的值。你只需要简单的告诉 Composer 你的项目需要依赖哪些包。 { \"require\": { \"monolog/monolog\": \"1.0.*\" } } 你可以看到， require需要一个 包名称 （例如 monolog/monolog） 映射到 包版本 （例如 1.0.*） 的对象。 包名称 包名称由供应商名称和其项目名称构成。通常容易产生相同的项目名称，而供应商名称的存在则很好的解决了命名冲突的问题。它允许两个不同的人创建同样名为 json 的库，而之后它们将被命名为 igorw/json和 seldaek/json。 这里我们需要引入 monolog/monolog，供应商名称与项目的名称相同，对于一个具有唯一名称的项目，我们推荐这么做。它还允许以后在同一个命名空间添加更多的相关项目。如果你维护着一个库，这将使你可以很容易的把它分离成更小的部分。 包版本 在前面的例子中，我们引入的 monolog 版本指定为 1.0.*。这表示任何从 1.0 开始的开发分支，它将会匹配 1.0.0、1.0.2或者1.0.20。 版本约束 可以用几个不同的方法来指定。 名称 实例 描述 确切的版本号 1.0.2 你可以指定包的确切版本。 范围 >=1.0 >=1.0,=1.0,=1.2 通过使用比较操作符可以指定有效的版本范围。有效的运算符：>、>=、 通配符 1.0.* 你可以使用通配符来指定一种模式。1.0.与>=1.0, 赋值运算符 ~1.2 这对于遵循语义化版本号的项目非常有用。~1.2相当于>=1.2, 下一个重要版本（波浪号运算符） ~ 最好用例子来解释：~1.2相当于>=1.2,，而 ~1.2.3相当于>=1.2.3,。正如你所看到的这对于遵循 语义化版本号 的项目最有用。一个常见的用法是标记你所依赖的最低版本，像 ~1.2（允许1.2以上的任何版本，但不包括2.0）。由于理论上直到2.0应该都没有向后兼容性问题，所以效果很好。你还会看到它的另一种用法，使用 ~指定最低版本，但允许版本号的最后一位数字上升。 注意： 虽然 2.0-beta.1 严格地说是早于 2.0，但是，根据版本约束条件， 例如 ~1.2 却不会安装这个版本。就像前面所讲的 ~1.2 只意味着 .2 部分可以改变，但是 1. 部分是固定的。 稳定性 默认情况下只有稳定的发行版才会被考虑在内。如果你也想获得 RC、beta、alpha 或 dev 版本，你可以使用 稳定标志。你可以对所有的包做 最小稳定性 设置，而不是每个依赖逐一设置。 安装依赖包 推荐使用install命令 composer install 接着前面的例子，这将会找到依赖组件的指定版本，并将它下载到 vendor 目录。 如果你正在使用Git来管理你的项目， 你可能要添加 vendor 到你的 .gitignore 文件中。 你不会希望将所有的代码都添加到你的版本库中。另一件事是 install 命令将创建一个 composer.lock 文件到你项目的根目录中。 composer.lock - 锁文件 在安装依赖后，Composer 将把安装时确切的版本号列表写入 composer.lock 文件。这将锁定改项目的特定版本。 请提交你应用程序的 composer.lock （包括 composer.json）到你的版本库中 这是非常重要的，因为 install命令将会检查锁文件是否存在，如果存在，它将下载指定的版本（忽略composer.json 文件中的定义）。 这意味着，任何人建立项目都将下载与指定版本完全相同的依赖。你的持续集成服务器、生产环境、你团队中的其他开发人员、每件事、每个人都使用相同的依赖，从而减轻潜在的错误对部署的影响。即使你独自开发项目，在六个月内重新安装项目时，你也可以放心的继续工作，即使从那时起你的依赖已经发布了许多新的版本。 如果不存在 composer.lock 文件，Composer 将读取 composer.json 并创建锁文件。 这意味着如果你的依赖更新了新的版本，你将不会获得任何更新。此时要更新你的依赖版本请使用 update 命令。这将获取最新匹配的版本（根据你的 composer.json 文件）并将新版本更新进锁文件。 compose update 如果只想安装或更新一个依赖。 compose update monolog/monolog 还有更多关于composer的操作，推荐查看： phpcomposer中文文档 composer命令全解 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 11:30:10 "},"php/composer/Composer使用技巧.html":{"url":"php/composer/Composer使用技巧.html","title":"Composer使用技巧","keywords":"","body":"一、拉取组件是不是很慢？ 换源（中国全量镜像） 修改 composer 的全局配置文件 打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令： composer config -g repo.packagist composer https://packagist.phpcomposer.com 镜像原理 一般情况下，安装包的数据（主要是 zip 文件）一般是从 github.com 上下载的，安装包的元数据是从 packagist.org 上下载的。 然而，由于众所周知的原因，国外的网站连接速度很慢，并且随时可能被“墙”甚至“不存在”。 “Packagist 中国全量镜像”所做的就是缓存所有安装包和元数据到国内的机房并通过国内的 CDN 进行加速，这样就不必再去向国外的网站发起请求，从而达到加速 composer install 以及 composer update 的过程，并且更加快速、稳定。因此，即使 packagist.org、github.com 发生故障（主要是连接速度太慢和被墙），你仍然可以下载、更新安装包。 二、安装应该使用哪个命令呢，install, update 还是 require ？ 举个例子 这个fork过百的composer管理的组件包，他的安装命令有问题。地址在此。 由于对composer命令的不准确理解，导致出现加载版本错误的情况。 composer update 这个命令在我们现在的逻辑中，可能会对项目造成巨大伤害。 因为composer update的逻辑是按照 composer.json指定的扩展包版本规则，把所有扩展包更新到最新版本，注意，是 所有扩展包，举个例子，你在项目一开始的时候使用了 monolog，当时的配置信息是 \"monolog/monolog\": \"1.*\", 后果 安装的是 monolog 1.1 版本，而一个多月以后的现在，monolog 已经是 1.2 了，运行命令后直接更新到 1.2，这时项目并没有针对 1.2 进行过测试，项目一下子变得很不稳定，情况有时候会比这个更糟糕，尤其是在一个庞大的项目中，你没有对项目写完整覆盖测试的情况，什么东西坏掉了你都不知道。 命令定义 composer install - 如有 composer.lock 文件，直接安装，否则从 composer.json 安装最新扩展包和依赖； composer update - 从 composer.json 安装最新扩展包和依赖； composer update vendor/package - 从 composer.json 或者对应包的配置，并更新到最新； composer require new/package - 添加安装 new/package, 可以指定版本，如： composer require new/package ~2.5. 下来介绍几个日常生产的流程，来方便加深大家的理解。 情景一：开发者引入新组件 创建 composer.json，并添加依赖到的扩展包； 运行 composer install，安装扩展包并生成 composer.lock； 提交 composer.lock 到git代码版本控制器中，不要加入忽略。 情景二：协作者安装现有组件 克隆或者更新项目后，其他开发者引入新的组件，这是我们需要也拉下来。根目录下直接运行 composer install 从 composer.lock 中安装 指定版本 的扩展包以及其依赖； 此流程适用于代码部署。 情景三：为项目添加新组件 使用 composer require vendor/package 添加扩展包， 可以规定版本号，如： composer require \"foo/bar:1.0.0\" 相比较情景一，更推荐require的方式对组件进行添加，升级操作。 三、拉取失败后怎么办？ 分析 每个人是从菜鸡阶段过来的，一开始，我们对 Composer 不熟，用的是官方源，非国内镜像，导致网络不稳定或者很慢很慢导致超时。往往一次不顺之后，再次拉取还是不行。 此时需要检查composer.json是否格式正确，不过一般我们不希望phper自己去修改composer.json文件，因为无论安装，卸载，升级，都可以通过composer命令进行管理。 原因 拉取失败很大几率是网速问题导致的。 解决 先清理cache composer clear-cache // Aliased to clearcache, clears composer's internal package cache. 清理chache之后，再次拉取就可以避免进入失败的死循环，同时建议更换国内源以提高网速和稳定性，如果条件具备可以挂网速稳定的vpn代理科学上网，保证composer顺利工作。 此时我们在项目中使用composer，基本没什么问题了。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 12:12:43 "},"php/laravel/Readme.html":{"url":"php/laravel/Readme.html","title":"Laravel框架","keywords":"","body":"Readme Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 09:59:49 "},"php/laravel/Laravel常见错误指南.html":{"url":"php/laravel/Laravel常见错误指南.html","title":"Laravel常见错误指南","keywords":"","body":"Laravel常见问题总结 1.Whoops, looks like something went wrong. 这个错误代表服务器出现错 解决方法：查看日志以及打开.env 修改APP_DEBUG 为true再重新刷新页面 2.当使用post提交数据时 报The page has expired due to inactivity. Please refresh and try again. 一般这个问题是由于表单缺少csrf令牌时 报错误 或者是路由选择访问的方式不是为post 解决方法 ： 在表单加上{{ csrf_field() }} 这个 或者在web路由更改相应的路由设置 3.Call to undefined function Illuminate\\Encryption\\openssl_cipher_iv_length() 一般出现这个问题是由于服务器缺少openssl这个php拓展 解决方法：装上即可 安装步骤： yum -y install openssl-devel 必须安装 yum -y install openssl-devel 必须安装 cd /lamp/php-7.0.7/ext/openssl mv config0.m4 config.m4 否则报错：找不到config.m4 /usr/local/php/bin/phpize ./configure --with-openssl --with-php-config=/usr/local/php/bin/php-config make make install 4. 禁止访问错误 一般出现这个问题是由于重写模块没有打开 解决方法： 在httpd.conf 中打开rewrite重写模块 在226行左右将 AllowOverride None 设置为All 然后重启apache即可 *FollowSymLinks 允许你的网页文件夹下的链接文件链接到首页目录以外的文件 5.使用composer安装laravel时出现问题 问题1.详解 Failed to download laravel/laravel from dist: The zip extension and unzip command are both missing, skipping. The php.ini used by your command-line PHP is: /usr/local/php/etc/php.ini c出现这个问题是由于环境中缺少zip跟unzip 解决方法 ：yum install zip unzip php7.0-zip 6.当同步更新laravel时发现视图层根本没更新 这是因为laravel 里面的storage\\framework\\views缓存问题 将里面东西都删除即可 7.利用composer装laravel 时报版本错误 命令错误 解决方法composer create-project --prefer-dist laravel/laravel=5.5 blog 8.服务器报500错误 这是由于服务器内部错误 一般是代码错误或者Apache错误 解决方法：打开php.ini 的display_error 中的错误报告 如果是Laravel框架则在配置文件打开调试模式 或者是缺少env这个文件 这个问题一般是由于git克隆或者直接复制文件夹问题 9.No application encryption key has been specified. 这是因为.env 配置文件中缺少key这个秘钥 解决方法； hp artisan key:generate 10 如果ajax post发起请求 出现419错误 由于没有csrf_token令牌的原因 解决方法： 在页面头部加一行 然后在ajax 的请求头里加多一行headers: {'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')}, Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-05 20:15:03 "},"php/PHP优化配置/Readme.html":{"url":"php/PHP优化配置/Readme.html","title":"PHP优化配置","keywords":"","body":"初始化 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-09 20:02:36 "},"php/PHP优化配置/PHP-FPM配置详解.html":{"url":"php/PHP优化配置/PHP-FPM配置详解.html","title":"PHP-FPM配置详解","keywords":"","body":"前言 本文章会详细介绍php-fpm配置文件的各个配置值，以及对应关系，目前大多数PHP应用采用nginx + php-fpm 的方式去运作，所以了解php-fpm的配置对优化服务器会有很大的帮助 配置详解 该配置为 Ubuntu 18.04 下 通过apt-get install 安装的php7.3-fpm生成的配置文件 运行php-fpm的用户以及用户组配置 user = www-data --运行php-fpm的用户 group = www-data --运行php-fpm的用户组 监听php-fpm的方式 listen = /run/php/php7.3-fpm.sock --fpm监听的sock文件 listen = 127.0.0.1:9000 --fpm监听的端口 监听php-fpm的方式有两种 第一次种是Unix domain socket模式 另外一种是TCP模式, TCP是使用TCP端口连接127.0.0.1:9000，Socket是使用unix domain socket连接套接字/dev/shm/php-cgi.sock，在服务器压力不大的情况下，tcp和socket差别不大，但在压力比较满的时候，用套接字方式，效果确实比较好。 从原理上来说，unix socket方式肯定要比tcp的方式快而且消耗资源少，因为socket之间在nginx和php-fpm的进程之间通信，而tcp需要经过本地回环驱动，还要申请临时端口和tcp相关资源。 当然还是从原理上来说，unix socket会显得不是那么稳定，当并发连接数爆发时，会产生大量的长时缓存，在没有面向连接协议支撑的情况下，大数据包很有可能就直接出错并不会返回异常。而TCP这样的面向连接的协议，多少可以保证通信的正确性和完整性。其实如果nginx做要做负载均衡的话，根本也不要考虑unix socket的方式了，只能采用TCP的方式。 backlog数 listen.backlog = 1024 ---1表示无限制，由操作系统决定，此行注释掉就行。 监听的用户以及用户组 listen.owner = www-data listen.group = www-data 允许监听的客户端 ip listen.allowed_clients = 127.0.0.1 处理nice(2)的进程优先级别-19(最高)到20(最低) process.priority = -19 php-fpm进程启动模式 ``` pm = dynamic -- 进程模式(dynamic static ondemand) pm.max_children = 16 -- 同一时刻能够存货的最大子进程的数量(static时有效) pm.start_servers = 10 -- 在启动时启动的子进程数量 pm.min_spare_servers = 1 -- 处于空闲\"idle\"状态的最小子进程，如果空闲进程数量小于这个值，那么相应的子进程会被创建 pm.min_spare_servers = 10 -- 最大空闲子进程数量，空闲子进程数量超过这个值，那么相应的子进程会被杀掉。 pm.process_idle_timeout = 10s; -- 请求超时数 pm.max_requests = 500 -- 最大请求数 8. 配置一个URI，以便查看fpm状态页 状态页描述： 　　accepted conn: 该进程池接受的请求数量 　　pool: 进程池的名字 　　process manager: 进程管理，就是配置中pm指令，可以选择值static，dynamic，ondemand 　　idle processes: 空闲进程数量 　　active processes: 当前活跃的进程数量 　　total processes: 总的进程数量=idle+active 　　max children reached: 达到最大子进程的次数，达到进程的限制，当pm试图开启更多的子进程的时候(仅当pm工作在dynamic时) 　　 pm.status_path = /status 9. FPM 监控页面的ping网址 ping.path = /ping -- 可以用于外部检测 fpm 是否存活并且可以相应请求，必须以斜线(/)开头。 10. 设定访问日志的格式 access.log = log/$pool.access.log -- 相对比于nginx 的 access.log，此日志记录的信息更利于做性能上的分析，可以记录 cpu, memory,time　 access.format = \"%R - %u %t \\\"%m %r%Q%q\\\" %s %f %{mili}d %{kilo}M %C%%\" 11. 记录慢请求日志/慢日志请求超时时间 slowlog = log/$pool.log.slow request_slowlog_timeout = 0 12. 终止请求超时时间，在 worker　进程杀掉之后，提供单个请求的超时时间 request_terminate_timeout = 0 ``` 启动模式详解 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 17:28:27 "},"php/设计模式/Readme.html":{"url":"php/设计模式/Readme.html","title":"PHP设计模式","keywords":"","body":"Readme Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-29 15:41:47 "},"php/设计模式/PHP面向对象设计的五个基准原则.html":{"url":"php/设计模式/PHP面向对象设计的五个基准原则.html","title":"设计原则","keywords":"","body":"S.O.L.I.D 是 首个 5 个面向对象设计(OOD) 准则的首字母缩写 ，这些准则是由 Robert C. Martin 提出的, 他更为人所熟知的名字是 Uncle Bob。 这些准则使得开发出易扩展、可维护的软件变得更容易。也使得代码更精简、易于重构。同样也是敏捷开发和自适应软件开发的一部分。 备注: 这不是一篇简单的介绍 \"欢迎来到 S.O.L.I.D\" 的文章，这篇文章想要阐明 S.O.L.I.D_ 是什么。 S.O.L.I.D 意思是： 扩展出来的首字母缩略词看起来可能很复杂，实际上它们很容易理解。 S - 单一功能原则 O - 开闭原则 L - 里氏替换原则 I - 接口隔离原则 D - 依赖反转原则 接下来让我们看看每个原则，来了解为什么 S.O.L.I.D 可以帮助我们成为更好的开发人员。 单一职责原则 缩写是 S.R.P ，该原则内容是: 一个类有且只能有一个因素使其改变，意思是一个类只应该有单一职责． 例如，假设我们有一些图形，并且想要计算这些图形的总面积．是的，这很简单对不对？ class Circle { public $radius; public function __construct($radius) { $this->radius = $radius; } } class Square { public $length; public function __construct($length) { $this->length = $length; } } 首先，我们创建图形类，该类的构造方法初始化必要的参数．接下来，创建AreaCalculator 类，然后编写计算指定图形总面积的逻辑代码． class AreaCalculator { protected $shapes; public function __construct($shapes = array()) { $this->shapes = $shapes; } public function sum() { // logic to sum the areas } public function output() { return implode('', array( \"\", \"Sum of the areas of provided shapes: \", $this->sum(), \"\" )); } } AreaCalculator 使用方法，我们只需简单的实例化这个类，并且传递一个图形数组，在页面底部展示输出内容． $shapes = array( new Circle(2), new Square(5), new Square(6) ); $areas = new AreaCalculator($shapes); echo $areas->output(); 输出方法的问题在于，AreaCalculator 处理了数据输出逻辑．因此，假如用户希望将数据以 json 或者其他格式输出呢？ 所有逻辑都由 AreaCalculator 类处理，这恰恰违反了单一职责原则(SRP); AreaCalculator 类应该只负责计算图形的总面积，它不应该关心用户是想要json还是HTML格式数据。 因此，要解决这个问题，可以创建一个 SumCalculatorOutputter 类，并使用它来处理所需的显示逻辑，以处理所有图形的总面积该如何显示。 SumCalculatorOutputter 类的工作方式如下： $shapes = array( new Circle(2), new Square(5), new Square(6) ); $areas = new AreaCalculator($shapes); $output = new SumCalculatorOutputter($areas); echo $output->JSON(); echo $output->HAML(); echo $output->HTML(); echo $output->JADE(); 现在，无论你想向用户输出什么格式数据，都由 SumCalculatorOutputter 类处理。 开闭原则 对象和实体应该对扩展开放，但是对修改关闭． 简单的说就是，一个类应该不用修改其自身就能很容易扩展其功能．让我们看一下 AreaCalculator 类，特别是 sum 方法． public function sum() { foreach($this->shapes as $shape) { if(is_a($shape, 'Square')) { $area[] = pow($shape->length, 2); } else if(is_a($shape, 'Circle')) { $area[] = pi() * pow($shape->radius, 2); } } return array_sum($area); } 如果我们想用 sum 方法能计算更多图形的面积，我们就不得不添加更多的 if/else blocks ，然而这违背了开闭原则． 让这个 sum 方法变得更好的方式是将计算每个形状面积的代码逻辑移出 sum 方法，将其放进各个形状类中： class Square { public $length; public function __construct($length) { $this->length = $length; } public function area() { return pow($this->length, 2); } } 相同的操作应该被用来处理 Circle 类, 在类中添加一个 area 方法。 现在，计算任何形状面积之和应该像下边这样简单： public function sum() { foreach($this->shapes as $shape) { $area[] = $shape->area(); } return array_sum($area); } 接下来我们可以创建另一个形状类并在计算总和时传递它而不破坏我们的代码。 然而现在又出现了另一个问题，我们怎么能知道传入 AreaCalculator 的对象实际上是一个形状，或者形状对象中有一个 area 方法？ 接口编码是实践 S.O.L.I.D 的一部分，例如下面的例子中我们创建一个接口类，每个形状类都会实现这个接口类： interface ShapeInterface { public function area(); } class Circle implements ShapeInterface { public $radius; public function __construct($radius) { $this->radius = $radius; } public function area() { return pi() * pow($this->radius, 2); } } 在我们的 AreaCalculator 的 sum 方法中，我们可以检查提供的形状类的实例是否是 ShapeInterface 的实现，否则我们就抛出一个异常： public function sum() { foreach($this->shapes as $shape) { if(is_a($shape, 'ShapeInterface')) { $area[] = $shape->area(); continue; } throw new AreaCalculatorInvalidShapeException; } return array_sum($area); } 里氏替换原则 如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 这句定义的意思是说：每个子类或者衍生类可以毫无问题地替代基类/父类。 依然使用 AreaCalculator 类, 假设我们有一个 VolumeCalculator 类，这个类继承了AreaCalculator 类： class VolumeCalculator extends AreaCalculator { public function construct($shapes = array()) { parent::construct($shapes); } public function sum() { // logic to calculate the volumes and then return and array of output return array($summedData); } } SumCalculatorOutputter 类: class SumCalculatorOutputter { protected $calculator; public function __construct(AreaCalculator $calculator) { $this->calculator = $calculator; } public function JSON() { $data = array( 'sum' => $this->calculator->sum(); ); return json_encode($data); } public function HTML() { return implode('', array( '', 'Sum of the areas of provided shapes: ', $this->calculator->sum(), '' )); } } 如果我们运行像这样一个例子： $areas = new AreaCalculator($shapes); $volumes = new AreaCalculator($solidShapes); $output = new SumCalculatorOutputter($areas); $output2 = new SumCalculatorOutputter($volumes); 程序不会出问题， 但当我们使用$output2 对象调用 HTML 方法时 ，我们接收到一个 E_NOTICE 错误，提示我们 数组被当做字符串使用的错误。 为了修复这个问题，只需： public function sum() { // logic to calculate the volumes and then return and array of output return $summedData; } 而不是让VolumeCalculator 类的 sum 方法返回数组。 $summedData 是一个浮点数、双精度浮点数或者整型。 接口隔离原则 使用方（client）不应该依赖强制实现不使用的接口，或不应该依赖不使用的方法。 继续使用上面的 shapes 例子，已知拥有一个实心块，如果我们需要计算形状的体积，我们可以在 ShapeInterface 中添加一个方法： interface ShapeInterface { public function area(); public function volume(); } 任何形状创建的时候必须实现 volume 方法，但是【平面】是没有体积的，实现这个接口会强制的让【平面】类去实现一个自己用不到的方法。 ISP 原则不允许这么去做，所以我们应该创建另外一个拥有 volume 方法的SolidShapeInterface 接口去代替这种方式，这样类似立方体的实心体就可以实现这个接口了： interface ShapeInterface { public function area(); } interface SolidShapeInterface { public function volume(); } class Cuboid implements ShapeInterface, SolidShapeInterface { public function area() { //计算长方体的表面积 } public function volume() { // 计算长方体的体积 } } 这是一个更好的方式，但是要注意提示类型时不要仅仅提示一个 ShapeInterface 或 SolidShapeInterface。 你能创建其它的接口，比如 ManageShapeInterface ,并在平面和立方体的类上实现它，这样你能很容易的看到有一个用于管理形状的api。例： interface ManageShapeInterface { public function calculate(); } class Square implements ShapeInterface, ManageShapeInterface { public function area() { /Do stuff here/ } public function calculate() { return $this->area(); } } class Cuboid implements ShapeInterface, SolidShapeInterface, ManageShapeInterface { public function area() { /Do stuff here/ } public function volume() { /Do stuff here/ } public function calculate() { return $this->area() + $this->volume(); } } 现在在 AreaCalculator 类中，我们可以很容易地用 calculate替换对area 方法的调用，并检查对象是否是 ManageShapeInterface 的实例，而不是 ShapeInterface 。 依赖倒置原则 最后，但绝不是最不重要的： 实体必须依赖抽象而不是具体的实现．即高等级模块不应该依赖低等级模块，他们都应该依赖抽象． 这也许听起来让人头大，但是它很容易理解．这个原则能够很好的解耦，举个例子似乎是解释这个原则最好的方法： class PasswordReminder { private $dbConnection; public function __construct(MySQLConnection $dbConnection) { $this->dbConnection = $dbConnection; } } 首先 MySQLConnection 是低等级模块，然而　PasswordReminder 是高等级模块，但是根据 S.O.L.I.D. 中 D 的解释：依赖于抽象而不依赖与实现， 上面的代码段违背了这一原则，因为 PasswordReminder 类被强制依赖于 MySQLConnection 类． 稍后，如果你希望修改数据库驱动，你也不得不修改 PasswordReminder 类，因此就违背了 Open-close principle． 此 PasswordReminder 类不应该关注你的应用使用了什么数据库，为了进一步解决这个问题，我们「面向接口写代码」，由于高等级和低等级模块都应该依赖于抽象，我们可以创建一个接口： interface DBConnectionInterface { public function connect(); } 这个接口有一个连接数据库的方法，MySQLConnection 类实现该接口，在 PasswordReminder 的构造方法中不要直接将类型约束设置为 MySQLConnection 类，而是设置为接口类，这样无论你的应用使用什么类型的数据库，PasswordReminder 类都能毫无问题地连接数据库，且不违背 开闭原则． class MySQLConnection implements DBConnectionInterface { public function connect() { return \"Database connection\"; } } class PasswordReminder { private $dbConnection; public function __construct(DBConnectionInterface $dbConnection) { $this->dbConnection = $dbConnection; } } 从上面一小段代码，你现在能看出高等级和低等级模块都依赖于抽象了。 总结 说实话，S.O.L.I.D 一开始似乎很难掌握，但只要不断地使用和遵守其原则，它将成为你的一部分，使你的代码易被扩展、修改，测试，即使重构也不容易出现问题。 文章转自：https://learnku.com/php/t/28922 更多文章：https://learnku.com/php/c/translations Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-29 15:42:54 "},"php/设计模式/单例模式.html":{"url":"php/设计模式/单例模式.html","title":"单例模式","keywords":"","body":"单例模式（Singleton Pattern） 单例模式(Singleton Pattern)：顾名思义，就是只有一个实例。作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 （一）为什么要使用PHP单例模式 1，php的应用主要在于数据库应用, 一个应用中会存在大量的数据库操作, 在使用面向对象的方式开发时, 如果使用单例模式, 则可以避免大量的new 操作消耗的资源,还可以减少数据库连接这样就不容易出现 too many connections情况。 2，如果系统中需要有一个类来全局控制某些配置信息, 那么使用单例模式可以很方便的实现. 这个可以参看zend Framework的FrontController部分。 3，在一次页面请求中, 便于进行调试, 因为所有的代码(例如数据库操作类db)都集中在一个类中, 我们可以在类中设置钩子, 输出日志，从而避免到处var_dump, echo （二）单例模式结构图 （三）单例模式的实现 1，私有化一个属性用于存放唯一的一个实例 2，私有化构造方法，私有化克隆方法，用来创建并只允许创建一个实例 3，公有化静态方法，用于向系统提供这个实例 （四）代码实现 class Singleton{ //存放实例 private static $_instance = null; //私有化构造方法、 private function __construct(){ echo \"单例模式的实例被构造了\"; } //私有化克隆方法 private function __clone(){ } //公有化获取实例方法 public static function getInstance(){ if (!(self::$_instance instanceof Singleton)){ self::$_instance = new Singleton(); } return self::$_instance; } } $singleton=Singleton::getInstance(); 优点 因为静态方法可以在全局范围内被访问，当我们需要一个单例模式的对象时，只需调用getInstance方法，获取先前实例化的对象，无需重新实例化。 （五）使用Trait关键字实现类似于继承单例类的功能 Trait Singleton{ //存放实例 private static $_instance = null; //私有化克隆方法 private function __clone(){ } //公有化获取实例方法 public static function getInstance(){ $class = __CLASS__; if (!(self::$_instance instanceof $class)){ self::$_instance = new $class(); } return self::$_instance; } } class DB { private function __construct(){ echo __CLASS__.PHP_EOL; } } class DBhandle extends DB { use Singleton; private function __construct(){ echo \"单例模式的实例被构造了\"; } } $handle=DBhandle::getInstance(); //注意若父类方法为public，则子类只能为pubic，若父类为private，子类为public ，protected，private都可以。 补充，大多数书籍介绍单例模式，都会讲三私一公，公有化静态方法作为提供对象的接口，私有属性用于存放唯一一个单例对象。私有化构造方法，私有化克隆方法保证只存在一个单例。 但实际上，虽然我们无法通过new 关键字和clone出一个新的对象，但我们若想得到一个新对象。还是有办法的，那就是通过序列化和反序列化得到一个对象。私有化sleep()和wakeup()方法依然无法阻止通过这种方法得到一个新对象。或许真得要阻止，你只能去__wakeup添加删除一个实例的代码，保证反序列化增加一个对象，你就删除一个。不过这样貌似有点怪异。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-29 16:23:57 "},"php/设计模式/工厂模式.html":{"url":"php/设计模式/工厂模式.html","title":"工厂模式","keywords":"","body":"工厂模式(Factor Pattern) 工厂模式(Factor Pattern)，就是负责生成其他对象的类或方法，也叫工厂方法模式 抽象工厂模式( Abstract Factor Pattern)，可简单理解为工厂模式的升级版 (一)为什么需要工厂模式 1，工厂模式可以将对象的生产从直接new 一个对象，改成通过调用一个工厂方法生产。这样的封装，代码若需修改new的对象时，不需修改多处new语句，只需更改生产对象方法。 2，若所需实例化的对象可选择来自不同的类，可省略if-else多层判断，给工厂方法传入对应的参数，利用多态性，实例化对应的类。 （二）工厂模式结构图 1，工厂方法模式 2，抽象工厂模式 （三）简单实现代码 //工厂类 class Factor{ //生成对象方法 static function createDB(){ echo '我生产了一个DB实例'; return new DB; } } //数据类 class DB{ public function __construct(){ echo __CLASS__.PHP_EOL; } } $db=Factor::createDB(); （四）实现一个运算器 //抽象运算类 abstract class Operation{ abstract public function getVal($i,$j);//抽象方法不能包含方法体 } //加法类 class OperationAdd extends Operation{ public function getVal($i,$j){ return $i+$j; } } //减法类 class OperationSub extends Operation{ public function getVal($i,$j){ return $i-$j; } } //计数器工厂 class CounterFactor { private static $operation; //工厂生产特定类对象方法 static function createOperation(string $operation){ switch($operation){ case '+' : self::$operation = new OperationAdd; break; case '-' : self::$operation = new OperationSub; break; } return self::$operation; } } $counter = CounterFactor::createOperation('+'); echo $counter->getVal(1,2); 缺点：若是再增加一个乘法运算，除了增加一个乘法运算类之外，还得去工厂生产方法里面添加对应的case代码，违反了开放-封闭原则。 解决方法（1）：通过传入指定类名 //计算器工厂 class CounterFactor { //工厂生产特定类对象方法 static function createOperation(string $operation){ return new $operation; } } class OperationMul extends Operation{ public function getVal($i,$j){ return $i*$j; } } $counter = CounterFactor::createOperation('OperationMul'); 解决方法（2）：通过抽象工厂模式 这里顺带提一个问题：如果我系统还有个生产一个文本输入器工厂，那么那个工厂和这个计数器工厂又有什么关系呢。 抽象高于实现 其实我们完全可以抽象出一个抽象工厂，然后将对应的对象生产交给子工厂实现。代码如下 //抽象运算类 abstract class Operation{ abstract public function getVal($i,$j);//抽象方法不能包含方法体 } //加法类 class OperationAdd extends Operation{ public function getVal($i,$j){ return $i+$j; } } //乘法类 class OperationMul extends Operation{ public function getVal($i,$j){ return $i*$j; } } //抽象工厂类 abstract class Factor{ abstract static function getInstance(); } //加法器生产工厂 class AddFactor extends Factor { //工厂生产特定类对象方法 static function getInstance(){ return new OperationAdd; } } //减法器生产工厂 class MulFactor extends Factor { static function getInstance(){ return new OperationMul; } } //文本输入器生产工厂 class TextFactor extends Factor{ static function getInstance(){} } $mul = MulFactor::getInstance(); echo $mul->getVal(1,2); Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-29 16:26:05 "},"php/设计模式/建造者模式.html":{"url":"php/设计模式/建造者模式.html","title":"建造者模式","keywords":"","body":"建造者模式(Builder Pattern) 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。 (一)为什么需要建造者模式 1，对象的生产需要复杂的初始化，比如给一大堆类成员属性赋初值，设置一下其他的系统环境变量。使用建造者模式可以将这些初始化工作封装起来。 2，对象的生成时可根据初始化的顺序或数据不同，而生成不同角色。 (二)建造者模式结构图 (三)模式应用 在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物 (四)设计实例 如果我们想创造出有一个person类，我们通过实例化时设置的属性不同，让他们两人一个是速度快的小孩，一个是知识深的长者 class person { public $age; public $speed; public $knowledge; } //抽象建造者类 abstract class Builder{ public $_person; public abstract function setAge(); public abstract function setSpeed(); public abstract function setKnowledge(); public function __construct(Person $person){ $this->_person=$person; } public function getPerson(){ return $this->_person; } } //长者建造者 class OlderBuider extends Builder{ public function setAge(){ $this->_person->age=70; } public function setSpeed(){ $this->_person->speed=\"low\"; } public function setKnowledge(){ $this->_person->knowledge='more'; } } //小孩建造者 class ChildBuider extends Builder{ public function setAge(){ $this->_person->age=10; } public function setSpeed(){ $this->_person->speed=\"fast\"; } public function setKnowledge(){ $this->_person->knowledge='litte'; } } //建造指挥者 class Director{ private $_builder; public function __construct(Builder $builder){ $this->_builder = $builder; } public function built(){ $this->_builder->setAge(); $this->_builder->setSpeed(); $this->_builder->setKnowledge(); } } //实例化一个长者建造者 $oldB = new OlderBuider(new Person); //实例化一个建造指挥者 $director = new Director($oldB); //指挥建造 $director->built(); //得到长者 $older = $oldB->getPerson(); var_dump($older); (五)总结 使用建造者模式时，我们把创建一个person实例的过程分为了两步. 一步是先交给对应角色的建造者，如长者建造者。这样的好处就把角色的属性设置封装了起来，我们不用在new一个person时，因为要得到一个older角色的实例，而在外面写了一堆$older->age=70。 另一步是交给了一个建造指挥者，调了一个built方法，通过先设置age，再设置Speed的顺序，初始化这个角色。当然在这个例子中，初始化的顺序，是无所谓的。但是如果对于一个建造汉堡，或是地图，初始化的顺序不同，可能就会得到不同的结果。 也许，你会说，我直接设置也很方便呀。是的，对于某些情况是这样的。但是如果你考虑，我现在想增加一个青年人角色呢？如果我现在想让建造有初始化有三种不同的顺序呢？ 如果你使用了建造者模式，这两个问题就简单了，增加一个青年人角色，那就增加一个青年年建造者类。初始化三种不同的顺序，那么就在指挥建造者中增加两种建造方法。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-29 16:26:18 "},"php/PHP版本新特性/Readme.html":{"url":"php/PHP版本新特性/Readme.html","title":"PHP版本新特性","keywords":"","body":"PHP各个版本新特性（7.0-7.2） php7发布已经升级到7.2.里面发生了很多的变化。本文整理php7.0至php7.2的新特性和一些变化。 参考资料： http://php.net/manual/zh/migration70.new-features.php http://php.net/manual/zh/migration71.new-features.php http://php.net/manual/zh/migration72.new-features.php Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 16:24:57 "},"php/PHP版本新特性/PHP7.0版本新特性.html":{"url":"php/PHP版本新特性/PHP7.0版本新特性.html","title":"PHP7.0版本新特性","keywords":"","body":"PHP7.0版本新特性 1. 组合比较符 () 组合比较符号用于比较两个表达式。当$a小于、等于或大于$b时它分别返回-1、0或1，比较规则延续常规比较规则。对象不能进行比较 var_dump('PHP' 'Node'); // int(1) var_dump(123 456); // int(-1) var_dump(['a', 'b'] ['a', 'b']); // int(0) 2. null合并运算符 由于日常使用中存在大量同时使用三元表达式和isset操作。使用null合并运算符可以简化操作 # php7以前 if(isset($_GET['a'])) { $a = $_GET['a']; } # php7以前 $a = isset($_GET['a']) ? $_GET['a'] : 'none'; #PHP 7 $a = $_GET['a'] ?? 'none'; 3. 变量类型声明 变量类型声明有两种模式。一种是强制的，和严格的。允许使用下列类型参数int、string、float、bool 同时不能再使用int、string、float、bool作为类的名字了 function sumOfInts(int ...$ints) { return array_sum($ints); } var_dump(sumOfInts(2, '3', 4.1)); // int(9) # 严格模式 declare(strict_types=1); function add(int $x, int $y) { return $x + $y; } var_dump(add('2', 3)); // Fatal error: Argument 1 passed to add() must be of the type integer 5. 返回值类型声明 增加了返回类型声明，类似参数类型。这样更方便的控制函数的返回值.在函数定义的后面加上:类型名即可 function fun(int $a): array { return $a; } fun(3);//Fatal error 6. 匿名类 php7允许new class {} 创建一个匿名的对象。 //php7以前 class Logger { public function log($msg) { echo $msg; } } $util->setLogger(new Logger()); // php7+ $util->setLogger(new class { public function log($msg) { echo $msg; } }); 7. Unicode codepoint 转译语法 这接受一个以16进制形式的 Unicode codepoint，并打印出一个双引号或heredoc包围的 UTF-8 编码格式的字符串。 可以接受任何有效的 codepoint，并且开头的 0 是可以省略的 echo \"\\u{aa}\";// ª echo \"\\u{0000aa}\";// ª echo \"\\u{9999}\";// 香 8. Closure::call 闭包绑定 简短干练的暂时绑定一个方法到对象上闭包并调用它。 class A {private $x = 1;} // PHP 7 之前版本的代码 $getXCB = function() {return $this->x;}; $getX = $getXCB->bindTo(new A, 'A'); // 中间层闭包 echo $getX(); // PHP 7+ 及更高版本的代码 $getX = function() {return $this->x;}; echo $getX->call(new A); 9. 带过滤的unserialize 提供更安全的方式解包不可靠的数据。它通过白名单的方式来防止潜在的代码注入 // 将所有的对象都转换为 __PHP_Incomplete_Class 对象 $data = unserialize($foo, [\"allowed_classes\" => false]); // 将除 MyClass 和 MyClass2 之外的所有对象都转换为 __PHP_Incomplete_Class 对象 $data = unserialize($foo, [\"allowed_classes\" => [\"MyClass\", \"MyClass2\"]); // 默认情况下所有的类都是可接受的，等同于省略第二个参数 $data = unserialize($foo, [\"allowed_classes\" => true]); 10. IntlChar类 这个类自身定义了许多静态方法用于操作多字符集的 unicode 字符。需要安装intl拓展 printf('%x', IntlChar::CODEPOINT_MAX); echo IntlChar::charName('@'); var_dump(IntlChar::ispunct('!')); 11. 预期 它使得在生产环境中启用断言为零成本，并且提供当断言失败时抛出特定异常的能力。以后可以使用这个这个进行断言测试 ini_set('assert.exception', 1); class CustomError extends AssertionError {} assert(false, new CustomError('Some error message')); 12. 命名空间按组导入 从同一个命名空间下导入的类、函数、常量支持按组一次导入 #php7以前 use app\\model\\A; use app\\model\\B; #php7+ use app\\model{A,B} 13.生成器支持返回表达式 它允许在生成器函数中通过使用 return 语法来返回一个表达式 （但是不允许返回引用值）， 可以通过调用 Generator::getReturn() 方法来获取生成器的返回值， 但是这个方法只能在生成器完成产生工作以后调用一次。 $gen = (function() { yield 1; yield 2; return 3; })(); foreach ($gen as $val) { echo $val, PHP_EOL; } # output //1 //2 echo $gen->getReturn(), PHP_EOL; # output //3 14.生成器委派 现在，只需在最外层生成其中使用yield from，就可以把一个生成器自动委派给其他的生成器 function gen() { yield 1; yield 2; yield from gen2(); } function gen2() { yield 3; yield 4; } foreach (gen() as $val) { echo $val, PHP_EOL; } 15.整数除法函数intdiv var_dump(intdiv(10,3)) //3 16.会话选项设置 session_start() 可以加入一个数组覆盖php.ini的配置 session_start([ 'cache_limiter' => 'private', 'read_and_close' => true, ]); 18. 随机数、随机字符函数 string random_bytes(int length); int random_int(int min, int max); 19. define 支持定义数组 #php7+ define('ALLOWED_IMAGE_EXTENSIONS', ['jpg', 'jpeg', 'gif', 'png']); Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 17:58:36 "},"algorithm/Readme.html":{"url":"algorithm/Readme.html","title":"算法 开发笔记","keywords":"","body":"Readme Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-20 11:28:59 "},"algorithm/leetcode/Readme.html":{"url":"algorithm/leetcode/Readme.html","title":"LeetCode每日一题","keywords":"","body":"Readme Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-20 11:29:11 "}}