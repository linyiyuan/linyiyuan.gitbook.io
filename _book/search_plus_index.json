{"./":{"url":"./","title":"项目简介","keywords":"","body":"项目简介     欢迎来到Choice→選的开发笔记，最近在整理自己的一些学习笔记，刚好在github看到了这么一个工具，所以拿来总结自己所有的开发笔记以及一些知识点，面试技巧等，希望对你有用 个人信息 个人博客：https://linyiyuan.github.io 个人简历：http://resume.linyiyuan.top GitHub地址：https://github.com/linyiyuan 掘金地址：https://juejin.im/user/5c749f1951882561dd7b7e83 知乎地址：https://www.zhihu.com/people/lin-yi-yuan-35-45/activities 微博地址：https://weibo.com/3118916401/ 个人标签 PHP后端开发、Laravel 、聚合支付、公众号开发、开源爱好者、Linux、 VueJs、极客 、Mysql CRM系统 联系信息 QQ：375133100 微信：13211035441 手机号码：13211035441 安装运行 # git clone 项目地址 # npm install # gitbook init # gitbook install # gitbook serve 关于GitBook的安装和使用 ➡️ https://www.jianshu.com/p/1f78d8018ea7 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-04 23:47:53 "},"php/PHP版本新特性/Readme.html":{"url":"php/PHP版本新特性/Readme.html","title":"PHP版本新特性","keywords":"","body":"PHP各个版本新特性（7.0-7.2） php7发布已经升级到7.2.里面发生了很多的变化。本文整理php7.0至php7.2的新特性和一些变化。 参考资料： http://php.net/manual/zh/migration70.new-features.php http://php.net/manual/zh/migration71.new-features.php http://php.net/manual/zh/migration72.new-features.php Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-11 23:34:22 "},"php/PHP版本新特性/PHP7.0版本新特性.html":{"url":"php/PHP版本新特性/PHP7.0版本新特性.html","title":"PHP7.0版本新特性","keywords":"","body":"PHP7.0版本新特性 1. 组合比较符 () 组合比较符号用于比较两个表达式。当$a小于、等于或大于$b时它分别返回-1、0或1，比较规则延续常规比较规则。对象不能进行比较 var_dump('PHP' 'Node'); // int(1) var_dump(123 456); // int(-1) var_dump(['a', 'b'] ['a', 'b']); // int(0) 2. null合并运算符 由于日常使用中存在大量同时使用三元表达式和isset操作。使用null合并运算符可以简化操作 # php7以前 if(isset($_GET['a'])) { $a = $_GET['a']; } # php7以前 $a = isset($_GET['a']) ? $_GET['a'] : 'none'; #PHP 7 $a = $_GET['a'] ?? 'none'; 3. 变量类型声明 变量类型声明有两种模式。一种是强制的，和严格的。允许使用下列类型参数int、string、float、bool 同时不能再使用int、string、float、bool作为类的名字了 function sumOfInts(int ...$ints) { return array_sum($ints); } var_dump(sumOfInts(2, '3', 4.1)); // int(9) # 严格模式 declare(strict_types=1); function add(int $x, int $y) { return $x + $y; } var_dump(add('2', 3)); // Fatal error: Argument 1 passed to add() must be of the type integer 5. 返回值类型声明 增加了返回类型声明，类似参数类型。这样更方便的控制函数的返回值.在函数定义的后面加上:类型名即可 function fun(int $a): array { return $a; } fun(3);//Fatal error 6. 匿名类 php7允许new class {} 创建一个匿名的对象。 //php7以前 class Logger { public function log($msg) { echo $msg; } } $util->setLogger(new Logger()); // php7+ $util->setLogger(new class { public function log($msg) { echo $msg; } }); 7. Unicode codepoint 转译语法 这接受一个以16进制形式的 Unicode codepoint，并打印出一个双引号或heredoc包围的 UTF-8 编码格式的字符串。 可以接受任何有效的 codepoint，并且开头的 0 是可以省略的 echo \"\\u{aa}\";// ª echo \"\\u{0000aa}\";// ª echo \"\\u{9999}\";// 香 8. Closure::call 闭包绑定 简短干练的暂时绑定一个方法到对象上闭包并调用它。 class A {private $x = 1;} // PHP 7 之前版本的代码 $getXCB = function() {return $this->x;}; $getX = $getXCB->bindTo(new A, 'A'); // 中间层闭包 echo $getX(); // PHP 7+ 及更高版本的代码 $getX = function() {return $this->x;}; echo $getX->call(new A); 9. 带过滤的unserialize 提供更安全的方式解包不可靠的数据。它通过白名单的方式来防止潜在的代码注入 // 将所有的对象都转换为 __PHP_Incomplete_Class 对象 $data = unserialize($foo, [\"allowed_classes\" => false]); // 将除 MyClass 和 MyClass2 之外的所有对象都转换为 __PHP_Incomplete_Class 对象 $data = unserialize($foo, [\"allowed_classes\" => [\"MyClass\", \"MyClass2\"]); // 默认情况下所有的类都是可接受的，等同于省略第二个参数 $data = unserialize($foo, [\"allowed_classes\" => true]); 10. IntlChar类 这个类自身定义了许多静态方法用于操作多字符集的 unicode 字符。需要安装intl拓展 printf('%x', IntlChar::CODEPOINT_MAX); echo IntlChar::charName('@'); var_dump(IntlChar::ispunct('!')); 11. 预期 它使得在生产环境中启用断言为零成本，并且提供当断言失败时抛出特定异常的能力。以后可以使用这个这个进行断言测试 ini_set('assert.exception', 1); class CustomError extends AssertionError {} assert(false, new CustomError('Some error message')); 12. 命名空间按组导入 从同一个命名空间下导入的类、函数、常量支持按组一次导入 #php7以前 use app\\model\\A; use app\\model\\B; #php7+ use app\\model{A,B} 13.生成器支持返回表达式 它允许在生成器函数中通过使用 return 语法来返回一个表达式 （但是不允许返回引用值）， 可以通过调用 Generator::getReturn() 方法来获取生成器的返回值， 但是这个方法只能在生成器完成产生工作以后调用一次。 $gen = (function() { yield 1; yield 2; return 3; })(); foreach ($gen as $val) { echo $val, PHP_EOL; } # output //1 //2 echo $gen->getReturn(), PHP_EOL; # output //3 14.生成器委派 现在，只需在最外层生成其中使用yield from，就可以把一个生成器自动委派给其他的生成器 function gen() { yield 1; yield 2; yield from gen2(); } function gen2() { yield 3; yield 4; } foreach (gen() as $val) { echo $val, PHP_EOL; } 15.整数除法函数intdiv var_dump(intdiv(10,3)) //3 16.会话选项设置 session_start() 可以加入一个数组覆盖php.ini的配置 session_start([ 'cache_limiter' => 'private', 'read_and_close' => true, ]); 18. 随机数、随机字符函数 string random_bytes(int length); int random_int(int min, int max); 19. define 支持定义数组 #php7+ define('ALLOWED_IMAGE_EXTENSIONS', ['jpg', 'jpeg', 'gif', 'png']); Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-11 23:34:22 "},"php/PSR规范/Readme.html":{"url":"php/PSR规范/Readme.html","title":"PSR规范","keywords":"","body":"PHP编码规范 PSR 是 PHP Standard Recommendations 的简写，由PHP FIG组织制定的 PHP 规范，是 PHP 开发的实践标准。 PHP FIG, FIG 是 Framework Interoperability Group（框架可互用性小组）的缩写，由几位开源框架的开发者成立于 2009 年，从那开始也选取了很多其他成员进来（包括但不限于Laravel, Joomla, Drupal, Composer, Phalcon, Slim, Symfony, Zend Framework等），虽然不是「官方」组织，但也代表了大部分的 PHP 社区。 项目的目的在于：通过框架作者或者框架的代表之间讨论，以最低程度的限制，制定一个协作标准，各个框架遵循统一的编码规范，避免各家自行发展的风格阻碍了 PHP 的发展，解决这个程序设计师由来已久的困扰。 目前官方已制定的规范包括以下六份文件： PSR-0 (已弃用) PSR-1 PSR-2 PSR-2补充 PSR-3 PSR-4 2014/04/25 添加PSR-2补充文件以及修改之前版本中的翻译不当与错误。 2014/07/31 添加PSR-4。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-11 23:34:22 "},"php/PSR规范/PSR-0.html":{"url":"php/PSR规范/PSR-0.html","title":"PSR-0","keywords":"","body":"PSR-0 RS-0规范是他们出的第1套规范，主要是制定了一些自动加载标准（Autoloading Standard)。 目前官网已经废弃了这一规范，以psr-4作为替代。如下文 Deprecated - As of 2014-10-21 PSR-0 has been marked as deprecated. PSR-4 is now recommended as an alternative. 大概意思： 不推荐使用 - 在2014年10月21日PSR-0已被标记为过时。PSR-4现在推荐作为替代。 PSR-0强制性要求几点： 一个完全合格的namespace和class必须符合这样的结构：“\\()*” 每个namespace必须有一个顶层的namespace（\"Vendor Name\"提供者名字） 每个namespace可以有多个子namespace 当从文件系统中加载时，每个namespace的分隔符(/)要转换成 DIRECTORY_SEPARATOR(操作系统路径分隔符) 在类名中，每个下划线(_)符号要转换成DIRECTORY_SEPARATOR(操作系统路径分隔符)。在namespace中，下划线(_)符号是没有（特殊）意义的 当从文件系统中载入时，合格的namespace和class一定是以 .php 结尾的 verdor name,namespaces,class名可以由大小写字母组合而成（大小写敏感的） Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-11 23:34:22 "},"php/PSR规范/PSR-1.html":{"url":"php/PSR规范/PSR-1.html","title":"PSR-1","keywords":"","body":"PSR-1 基本代码规范 本篇规范制定了代码基本元素的相关标准， 以确保共享的PHP代码间具有较高程度的技术互通性。 关键词 “必须”(“MUST”)、“一定不可/一定不能”(“MUST NOT”)、“需要”(“REQUIRED”)、 “将会”(“SHALL”)、“不会”(“SHALL NOT”)、“应该”(“SHOULD”)、“不该”(“SHOULD NOT”)、 “推荐”(“RECOMMENDED”)、“可以”(“MAY”)和”可选“(“OPTIONAL”)的详细描述可参见 RFC 2119 。 1. 概览 PHP代码文件必须以 2. 文件 2.1. PHP标签 PHP代码必须使用 长标签 或 短输出标签； 一定不可使用其它自定义标签。 2.2. 字符编码 PHP代码必须且只可使用不带BOM的UTF-8编码。 2.3. 从属效应（副作用） 一份PHP文件中应该要不就只定义新的声明，如类、函数或常量等不产生从属效应的操作，要不就只有会产生从属效应的逻辑操作，但不该同时具有两者。 “从属效应”(side effects)一词的意思是，仅仅通过包含文件，不直接声明类、 函数和常量等，而执行的逻辑操作。 “从属效应”包含却不仅限于：生成输出、直接的 require 或 include、连接外部服务、修改 ini 配置、抛出错误或异常、修改全局或静态变量、读或写文件等。 以下是一个反例，一份包含声明以及产生从属效应的代码： \\n\"; // 声明函数 functionfoo(){ // 函数主体部分 } 下面是一个范例，一份只包含声明不产生从属效应的代码： 3. 命名空间和类 命名空间以及类的命名必须遵循 PSR-0. 根据规范，每个类都独立为一个文件，且命名空间至少有一个层次：顶级的组织名称（vendor name）。 类的命名必须 遵循 StudlyCaps 大写开头的驼峰命名规范。 PHP 5.3及以后版本的代码必须使用正式的命名空间。 例如： 5.2.x及之前的版本应该使用伪命名空间的写法，约定俗成使用顶级的组织名称（vendor name）如 Vendor_ 为类前缀。 4. 类的常量、属性和方法 此处的“类”指代所有的类、接口以及可复用代码块（traits） 4.1. 常量 类的常量中所有字母都必须大写，词间以下划线分隔。 参照以下代码： 4.2. 属性 类的属性命名可以遵循 大写开头的驼峰式 ($StudlyCaps)、小写开头的驼峰式 ($camelCase) 又或者是 下划线分隔式 ($under_score)，本规范不做强制要求，但无论遵循哪种命名方式，都应该在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。 4.3. 方法 方法名称必须符合 camelCase() 式的小写开头驼峰命名规范。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-11 23:34:22 "},"php/PSR规范/PSR-2.html":{"url":"php/PSR规范/PSR-2.html","title":"PSR-2","keywords":"","body":"PSR-2 代码风格规范 本篇规范是 PSR-1 基本代码规范的继承与扩展。 本规范希望通过制定一系列规范化PHP代码的规则，以减少在浏览不同作者的代码时，因代码风格的不同而造成不便。 当多名程序员在多个项目中合作时，就需要一个共同的编码规范， 而本文中的风格规范源自于多个不同项目代码风格的共同特性， 因此，本规范的价值在于我们都遵循这个编码风格，而不是在于它本身。 关键词 “必须”(“MUST”)、“一定不可/一定不能”(“MUST NOT”)、“需要”(“REQUIRED”)、 “将会”(“SHALL”)、“不会”(“SHALL NOT”)、“应该”(“SHOULD”)、“不该”(“SHOULD NOT”)、 “推荐”(“RECOMMENDED”)、“可以”(“MAY”)和”可选“(“OPTIONAL”)的详细描述可参见 RFC 2119 。 1. 概览 代码必须遵循 PSR-1 中的编码规范 。 代码必须使用4个空格符而不是 tab键 进行缩进。 每行的字符数应该软性保持在80个之内， 理论上一定不可多于120个， 但一定不能有硬性限制。 每个 namespace 命名空间声明语句和 use 声明语句块后面，必须插入一个空白行。 类的开始花括号({)必须写在函数声明后自成一行，结束花括号(})也必须写在函数主体后自成一行。 方法的开始花括号({)必须写在函数声明后自成一行，结束花括号(})也必须写在函数主体后自成一行。 类的属性和方法必须添加访问修饰符（private、protected 以及 public）， abstract 以及 final必须声明在访问修饰符之前，而 static必须声明在访问修饰符之后。 控制结构的关键字后必须要有一个空格符，而调用方法或函数时则一定不能有。 控制结构的开始花括号({)必须写在声明的同一行，而结束花括号(})必须写在主体后自成一行。 控制结构的开始左括号后和结束右括号前，都一定不能有空格符。 1.1. 例子 以下例子程序简单地展示了以上大部分规范： $b) { $foo->bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static functionbar() { // method body } } ## 2. 通则 ### 2.1 基本编码准则 代码必须符合 PSR-1 中的所有规范。 ### 2.2 文件 所有PHP文件必须使用Unix LF (linefeed)作为行的结束符。 所有PHP文件必须以一个空白行作为结束。 纯PHP代码文件必须省略最后的 ?> 结束标签。 2.3. 行 行的长度一定不能有硬性的约束。 软性的长度约束一定要限制在120个字符以内，若超过此长度，带代码规范检查的编辑器一定要发出警告，不过一定不可发出错误提示。 每行不应该多于80个字符，大于80字符的行应该折成多行。 非空行后一定不能有多余的空格符。 空行可以使得阅读代码更加方便以及有助于代码的分块。 每行一定不能存在多于一条语句。 2.4. 缩进 代码必须使用4个空格符的缩进，一定不能用 tab键 。 备注: 使用空格而不是tab键缩进的好处在于， 避免在比较代码差异、打补丁、重阅代码以及注释时产生混淆。 并且，使用空格缩进，让对齐变得更方便。 2.5. 关键字 以及 True/False/Null PHP所有 关键字必须全部小写。 常量 true 、false 和 null 也必须全部小写。 3. namespace 以及 use 声明 namespace 声明后 必须 插入一个空白行。 所有 use 必须 在 namespace 后声明。 每条 use 声明语句 必须 只有一个 use 关键词。 use 声明语句块后 必须 要有一个空白行。 例如： 4. 类、属性和方法 此处的“类”泛指所有的class类、接口以及traits可复用代码块。 4.1. 扩展与继承 关键词 extends 和 implements必须写在类名称的同一行。 类的开始花括号必须独占一行，结束花括号也必须在类主体后独占一行。 implements 的继承列表也可以分成多行，这样的话，每个继承接口名称都必须分开独立成行，包括第一个。 4.2. 属性 每个属性都必须添加访问修饰符。 一定不可使用关键字 var 声明一个属性。 每条语句一定不可定义超过一个属性。 不要使用下划线作为前缀，来区分属性是 protected 或 private。 以下是属性声明的一个范例： 4.3. 方法 所有方法都必须添加访问修饰符。 不要使用下划线作为前缀，来区分方法是 protected 或 private。 方法名称后一定不能有空格符，其开始花括号必须独占一行，结束花括号也必须在方法主体后单独成一行。参数左括号后和右括号前一定不能有空格。 一个标准的方法声明可参照以下范例，留意其括号、逗号、空格以及花括号的位置。 4.4. 方法的参数 参数列表中，每个参数后面必须要有一个空格，而前面一定不能有空格。 有默认值的参数，必须放到参数列表的末尾。 参数列表可以分列成多行，这样，包括第一个参数在内的每个参数都必须单独成行。 拆分成多行的参数列表后，结束括号以及方法开始花括号 必须 写在同一行，中间用一个空格分隔。 4.5. abstract 、 final 、 以及 static 需要添加 abstract 或 final 声明时， 必须写在访问修饰符前，而 static 则必须写在其后。 4.6. 方法及函数调用 方法及函数调用时，方法名或函数名与参数左括号之间一定不能有空格，参数右括号前也 一定不能有空格。每个参数前一定不能有空格，但其后必须有一个空格。 bar($arg1); Foo::bar($arg2, $arg3); 参数可以分列成多行，此时包括第一个参数在内的每个参数都必须单独成行。 bar( $longArgument, $longerArgument, $muchLongerArgument ); 5. 控制结构 控制结构的基本规范如下： 控制结构关键词后必须有一个空格。 左括号 ( 后一定不能有空格。 右括号 ) 前也一定不能有空格。 右括号 ) 与开始花括号 { 间一定有一个空格。 结构体主体一定要有一次缩进。 结束花括号 }一定在结构体主体后单独成行。 每个结构体的主体都必须被包含在成对的花括号之中， 这能让结构体更加结构话，以及减少加入新行时，出错的可能性。 5.1. if 、 elseif 和 else 标准的 if 结构如下代码所示，留意 括号、空格以及花括号的位置， 注意 else 和 elseif 都与前面的结束花括号在同一行。 应该使用关键词 elseif 代替所有 else if ，以使得所有的控制关键字都像是单独的一个词。 5.2. switch 和 case 标准的 switch 结构如下代码所示，留意括号、空格以及花括号的位置。 case 语句必须相对 switch 进行一次缩进，而 break 语句以及 case 内的其它语句都 必须 相对 case 进行一次缩进。 如果存在非空的 case 直穿语句，主体里必须有类似 // no break 的注释。 5.3. while 和 do while 一个规范的 while 语句应该如下所示，注意其 括号、空格以及花括号的位置。 标准的 do while 语句如下所示，同样的，注意其 括号、空格以及花括号的位置。 5.4. for 标准的 for 语句如下所示，注意其 括号、空格以及花括号的位置。 5.5. foreach 标准的 foreach 语句如下所示，注意其 括号、空格以及花括号的位置。 $value) { // foreach body } 5.6. try, catch 标准的 try catch 语句如下所示，注意其 括号、空格以及花括号的位置。 6. 闭包 闭包声明时，关键词 function 后以及关键词 use 的前后都必须要有一个空格。 开始花括号必须写在声明的同一行，结束花括号必须紧跟主体结束的下一行。 参数列表和变量列表的左括号后以及右括号前，必须不能有空格。 参数和变量列表中，逗号前必须不能有空格，而逗号后必须要有空格。 闭包中有默认值的参数必须放到列表的后面。 标准的闭包声明语句如下所示，注意其 括号、逗号、空格以及花括号的位置。 参数列表以及变量列表可以分成多行，这样，包括第一个在内的每个参数或变量都必须单独成行，而列表的右括号与闭包的开始花括号必须放在同一行。 以下几个例子，包含了参数和变量列表被分成多行的多情况。 bar( $arg1, function($arg2)use($var1){ // body }, $arg3 ); Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-11 23:34:22 "},"php/PSR规范/PSR-3.html":{"url":"php/PSR规范/PSR-3.html","title":"PSR-3","keywords":"","body":"PSR-3 日志接口规范 本文制定了日志类库的通用接口规范。 本规范的主要目的，是为了让日志类库以简单通用的方式，通过接收一个 Psr\\Log\\LoggerInterface 对象，来记录日志信息。 框架以及CMS内容管理系统如有需要，可以对此接口进行扩展，但需遵循本规范， 这才能保证在使用第三方的类库文件时，日志接口仍能正常对接。 关键词 “必须”(“MUST”)、“一定不可/一定不能”(“MUST NOT”)、“需要”(“REQUIRED”)、 “将会”(“SHALL”)、“不会”(“SHALL NOT”)、“应该”(“SHOULD”)、“不该”(“SHOULD NOT”)、 “推荐”(“RECOMMENDED”)、“可以”(“MAY”)和”可选“(“OPTIONAL”)的详细描述可参见 RFC 2119 。 本文中的 实现者 指的是实现了 LoggerInterface 接口的类库或者框架，反过来讲，他们就是 LoggerInterface 的 使用者。 1. 规范说明 1.1 基本规范 LoggerInterface 接口对外定义了八个方法，分别用来记录 RFC 5424 中定义的八个等级的日志：debug、 info、 notice、 warning、 error、 critical、 alert 以及 emergency 。 第九个方法 —— log，其第一个参数为记录的等级。可使用一个预先定义的等级常量作为参数来调用此方法，必须与直接调用以上八个方法具有相同的效果。如果传入的等级常量参数没有预先定义，则必须抛出 Psr\\Log\\InvalidArgumentException 类型的异常。在不确定的情况下，使用者不该使用未支持的等级常量来调用此方法。 1.2 记录信息 以上每个方法都接受一个字符串类型或者是有 __toString() 方法的对象作为记录信息参数，这样，实现者就能把它当成字符串来处理，否则实现者必须自己把它转换成字符串。 记录信息参数可以携带占位符，实现者可以根据上下文将其它替换成相应的值。 其中占位符必须与上下文数组中的键名保持一致。 占位符的名称必须由一个左花括号 { 以及一个右括号 } 包含。但花括号与名称之间一定不能有空格符。 占位符的名称应该只由 A-Z、 a-z,0-9、下划线 _、以及英文的句号 .组成，其它字符作为将来占位符规范的保留。 实现者可以通过对占位符采用不同的转义和转换策略，来生成最终的日志。 而使用者在不知道上下文的前提下，不该提前转义占位符。 以下是一个占位符使用的例子： /** * 用上下文信息替换记录信息中的占位符 */ function interpolate($message, array $context = array()){ // 构建一个花括号包含的键名的替换数组 $replace = array(); foreach ($context as $key => $val) { $replace['{' . $key . '}'] = $val; } // 替换记录信息中的占位符，最后返回修改后的记录信息。 return strtr($message, $replace); } // 含有带花括号占位符的记录信息。 $message = \"User {username} created\"; // 带有替换信息的上下文数组，键名为占位符名称，键值为替换值。 $context = array('username' => 'bolivar'); // 输出 \"Username bolivar created\" echo interpolate($message, $context); 1.3 上下文 每个记录函数都接受一个上下文数组参数，用来装载字符串类型无法表示的信息。它可以装载任何信息，所以实现者必须确保能正确处理其装载的信息，对于其装载的数据，一定不能 抛出异常，或产生PHP出错、警告或提醒信息（error、warning、notice）。 如需通过上下文参数传入了一个 Exception 对象， 必须以 'exception' 作为键名。 记录异常信息是很普遍的，所以如果它能够在记录类库的底层实现，就能够让实现者从异常信息中抽丝剥茧。 当然，实现者在使用它时，必须确保键名为 'exception' 的键值是否真的是一个 Exception，毕竟它可以装载任何信息。 1.4 助手类和接口 Psr\\Log\\AbstractLogger 类使得只需继承它和实现其中的 log 方法，就能够很轻易地实现 LoggerInterface 接口，而另外八个方法就能够把记录信息和上下文信息传给它。 同样地，使用 Psr\\Log\\LoggerTrait 也只需实现其中的 log 方法。不过，需要特别注意的是，在traits可复用代码块还不能实现接口前，还需要 implement LoggerInterface。 在没有可用的日志记录器时， Psr\\Log\\NullLogger 接口可以为使用者提供一个备用的日志“黑洞”。不过，当上下文的构建非常消耗资源时，带条件检查的日志记录或许是更好的办法。 Psr\\Log\\LoggerAwareInterface 接口仅包括一个 setLogger(LoggerInterface $logger) 方法，框架可以使用它实现自动连接任意的日志记录实例。 Psr\\Log\\LoggerAwareTrait trait可复用代码块可以在任何的类里面使用，只需通过它提供的 $this->logger，就可以轻松地实现等同的接口。 Psr\\Log\\LogLevel 类装载了八个记录等级常量。 包 上述的接口、类和相关的异常类，以及一系列的实现检测文件，都包含在 psr/log 文件包中。 3. Psr\\Log\\LoggerInterface 4. Psr\\Log\\LoggerAwareInterface 5. Psr\\Log\\LogLevel Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-11 23:34:22 "},"php/PSR规范/PSR-4.html":{"url":"php/PSR规范/PSR-4.html","title":"PSR-4","keywords":"","body":"自动载入规范 关键词 “必须”(“MUST”)、“一定不可/一定不能”(“MUST NOT”)、“需要”(“REQUIRED”)、 “将会”(“SHALL”)、“不会”(“SHALL NOT”)、“应该”(“SHOULD”)、“不该”(“SHOULD NOT”)、 “推荐”(“RECOMMENDED”)、“可以”(“MAY”)和”可选“(“OPTIONAL”)。 1. 概述 本 PSR 是关于由文件路径 [自动载入][http://tools.ietf.org/html/rfc2119] 对应类的相关规范， 本规范是可互操作的，可以作为任一自动载入规范的补充，其中包括 PSR-0，此外， 本 PSR 还包括自动载入的类对应的文件存放路径规范。 2. 详细说明 此处的“类”泛指所有的class类、接口、traits可复用代码块以及其它类似结构。 一个完整的类名需具有以下结构: \\(\\)*\\ 完整的类名必须要有一个顶级命名空间，被称为 “vendor namespace”； 完整的类名可以有一个或多个子命名空间； 完整的类名必须有一个最终的类名； 完整的类名中任意一部分中的下滑线都是没有特殊含义的； 完整的类名可以由任意大小写字母组成； 所有类名都必须是大小写敏感的。 当根据完整的类名载入相应的文件…… 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为“命名空间前缀”，其必须与至少一个“文件基目录”相对应； 紧接命名空间前缀后的子命名空间必须与相应的”文件基目录“相匹配，其中的命名空间分隔符将作为目录分隔符。 末尾的类名必须与对应的以 .php 为后缀的文件同名。 自动加载器（autoloader）的实现一定不能抛出异常、一定不能触发任一级别的错误信息以及不应该有返回值。 3. 例子 下表展示了符合规范完整类名、命名空间前缀和文件基目录所对应的文件路径。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-11 23:34:22 "},"php/Readme.html":{"url":"php/Readme.html","title":"PHP优化配置","keywords":"","body":"初始化 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 01:33:15 "},"php/PHP-FPM配置详解.html":{"url":"php/PHP-FPM配置详解.html","title":"PHP-FPM配置详解","keywords":"","body":"前言 本文章会详细介绍php-fpm配置文件的各个配置值，以及对应关系，目前大多数PHP应用采用nginx + php-fpm 的方式去运作，所以了解php-fpm的配置对优化服务器会有很大的帮助 配置详解 该配置为 Ubuntu 18.04 下 通过apt-get install 安装的php7.3-fpm生成的配置文件 运行php-fpm的用户以及用户组配置 user = www-data --运行php-fpm的用户 group = www-data --运行php-fpm的用户组 监听php-fpm的方式 listen = /run/php/php7.3-fpm.sock --fpm监听的sock文件 listen = 127.0.0.1:9000 --fpm监听的端口 监听php-fpm的方式有两种 第一次种是Unix domain socket模式 另外一种是TCP模式, TCP是使用TCP端口连接127.0.0.1:9000，Socket是使用unix domain socket连接套接字/dev/shm/php-cgi.sock，在服务器压力不大的情况下，tcp和socket差别不大，但在压力比较满的时候，用套接字方式，效果确实比较好。 从原理上来说，unix socket方式肯定要比tcp的方式快而且消耗资源少，因为socket之间在nginx和php-fpm的进程之间通信，而tcp需要经过本地回环驱动，还要申请临时端口和tcp相关资源。 当然还是从原理上来说，unix socket会显得不是那么稳定，当并发连接数爆发时，会产生大量的长时缓存，在没有面向连接协议支撑的情况下，大数据包很有可能就直接出错并不会返回异常。而TCP这样的面向连接的协议，多少可以保证通信的正确性和完整性。其实如果nginx做要做负载均衡的话，根本也不要考虑unix socket的方式了，只能采用TCP的方式。 backlog数 listen.backlog = 1024 ---1表示无限制，由操作系统决定，此行注释掉就行。 监听的用户以及用户组 listen.owner = www-data listen.group = www-data 允许监听的客户端 ip listen.allowed_clients = 127.0.0.1 处理nice(2)的进程优先级别-19(最高)到20(最低) process.priority = -19 php-fpm进程启动模式 ``` pm = dynamic -- 进程模式(dynamic static ondemand) pm.max_children = 16 -- 同一时刻能够存货的最大子进程的数量(static时有效) pm.start_servers = 10 -- 在启动时启动的子进程数量 pm.min_spare_servers = 1 -- 处于空闲\"idle\"状态的最小子进程，如果空闲进程数量小于这个值，那么相应的子进程会被创建 pm.min_spare_servers = 10 -- 最大空闲子进程数量，空闲子进程数量超过这个值，那么相应的子进程会被杀掉。 pm.process_idle_timeout = 10s; -- 请求超时数 pm.max_requests = 500 -- 最大请求数 8. 配置一个URI，以便查看fpm状态页 状态页描述： 　　accepted conn: 该进程池接受的请求数量 　　pool: 进程池的名字 　　process manager: 进程管理，就是配置中pm指令，可以选择值static，dynamic，ondemand 　　idle processes: 空闲进程数量 　　active processes: 当前活跃的进程数量 　　total processes: 总的进程数量=idle+active 　　max children reached: 达到最大子进程的次数，达到进程的限制，当pm试图开启更多的子进程的时候(仅当pm工作在dynamic时) 　　 pm.status_path = /status 9. FPM 监控页面的ping网址 ping.path = /ping -- 可以用于外部检测 fpm 是否存活并且可以相应请求，必须以斜线(/)开头。 10. 设定访问日志的格式 access.log = log/$pool.access.log -- 相对比于nginx 的 access.log，此日志记录的信息更利于做性能上的分析，可以记录 cpu, memory,time　 access.format = \"%R - %u %t \\\"%m %r%Q%q\\\" %s %f %{mili}d %{kilo}M %C%%\" 11. 记录慢请求日志/慢日志请求超时时间 slowlog = log/$pool.log.slow request_slowlog_timeout = 0 12. 终止请求超时时间，在 worker　进程杀掉之后，提供单个请求的超时时间 request_terminate_timeout = 0 ``` 启动模式详解 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 01:44:12 "},"laravel/Laravel常见错误指南.html":{"url":"laravel/Laravel常见错误指南.html","title":"Laravel常见错误指南","keywords":"","body":"Laravel常见问题总结 1.Whoops, looks like something went wrong. 这个错误代表服务器出现错 解决方法：查看日志以及打开.env 修改APP_DEBUG 为true再重新刷新页面 2.当使用post提交数据时 报The page has expired due to inactivity. Please refresh and try again. 一般这个问题是由于表单缺少csrf令牌时 报错误 或者是路由选择访问的方式不是为post 解决方法 ： 在表单加上{{ csrf_field() }} 这个 或者在web路由更改相应的路由设置 3.Call to undefined function Illuminate\\Encryption\\openssl_cipher_iv_length() 一般出现这个问题是由于服务器缺少openssl这个php拓展 解决方法：装上即可 安装步骤： yum -y install openssl-devel 必须安装 yum -y install openssl-devel 必须安装 cd /lamp/php-7.0.7/ext/openssl mv config0.m4 config.m4 否则报错：找不到config.m4 /usr/local/php/bin/phpize ./configure --with-openssl --with-php-config=/usr/local/php/bin/php-config make make install 4. 禁止访问错误 一般出现这个问题是由于重写模块没有打开 解决方法： 在httpd.conf 中打开rewrite重写模块 在226行左右将 AllowOverride None 设置为All 然后重启apache即可 *FollowSymLinks 允许你的网页文件夹下的链接文件链接到首页目录以外的文件 5.使用composer安装laravel时出现问题 问题1.详解 Failed to download laravel/laravel from dist: The zip extension and unzip command are both missing, skipping. The php.ini used by your command-line PHP is: /usr/local/php/etc/php.ini c出现这个问题是由于环境中缺少zip跟unzip 解决方法 ：yum install zip unzip php7.0-zip 6.当同步更新laravel时发现视图层根本没更新 这是因为laravel 里面的storage\\framework\\views缓存问题 将里面东西都删除即可 7.利用composer装laravel 时报版本错误 命令错误 解决方法composer create-project --prefer-dist laravel/laravel=5.5 blog 8.服务器报500错误 这是由于服务器内部错误 一般是代码错误或者Apache错误 解决方法：打开php.ini 的display_error 中的错误报告 如果是Laravel框架则在配置文件打开调试模式 或者是缺少env这个文件 这个问题一般是由于git克隆或者直接复制文件夹问题 9.No application encryption key has been specified. 这是因为.env 配置文件中缺少key这个秘钥 解决方法； hp artisan key:generate 10 如果ajax post发起请求 出现419错误 由于没有csrf_token令牌的原因 解决方法： 在页面头部加一行 然后在ajax 的请求头里加多一行headers: {'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')}, Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 01:33:15 "},"laravel/Laravel框架给多个视图分配数据.html":{"url":"laravel/Laravel框架给多个视图分配数据.html","title":"Laravel框架给多个视图分配数据","keywords":"","body":"步骤如下 以下假设需要将数据共享给Home/index以及Home/user视图 a. 创建服务提供者 //这条命令会在app/Providers目录创建ShareUserDataProvider.php php artisan make:provider ShareUserDataProvider b. 将上一步创建好的服务提供者，添加到配置文件中 在config.php/app.php配置文件中， 'providers' => [ // 其他服务提供器 App\\Providers\\ShareUserDataProvider::class, ], c. 在ShareUserDataProvider类文件中的boot方法 use Illuminate\\Support\\Facades\\View; //Home/index,Home/user都是视图名 View::composer( ['Home/index', 'Home/user'], 'App\\Http\\ViewComposers\\ProfileComposer' ); d. 创建App\\Http\\ViewComposers\\ProfileComposer d-1. 在app/Http目录下创建一个ViewComposers目录 mkdir ViewComposers`d-2. 在ViewComposers目录下创建ProfileComposer文件 touch ProfileComposer.php user = $index; } /** * 绑定数据到视图. * * @param View $view * @return void */ public function compose(View $view) { ////在视图中使用{{$count}}拿到aa $view->with('count', 'aa'); ////拿到UserApi类的test()方法的返回数据，并且分配到模板 $view->with('userdata', $this->user->test() ); } } //视图被渲染前，Composer 类的 compose 方法被调用，同时 Illuminate\\View\\View 实例被注入该方法，从而可以使用其 with 方法来绑定数据到视图。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 01:33:15 "}}