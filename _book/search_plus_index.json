{"./":{"url":"./","title":"项目简介","keywords":"","body":"项目简介     欢迎来到Choice→選的开发笔记，最近在整理自己的一些学习笔记，刚好在github看到了这么一个工具，所以拿来总结自己所有的开发笔记以及一些知识点，面试技巧等，希望对你有用 个人信息 个人博客：https://linyiyuan.github.io 个人简历：http://resume.linyiyuan.top GitHub地址：https://github.com/linyiyuan 掘金地址：https://juejin.im/user/5c749f1951882561dd7b7e83 知乎地址：https://www.zhihu.com/people/lin-yi-yuan-35-45/activities 微博地址：https://weibo.com/3118916401/ 个人标签 PHP后端开发、Laravel 、聚合支付、公众号开发、开源爱好者、Linux、 VueJs、极客 、Mysql CRM系统 联系信息 QQ：375133100 微信：13211035441 手机号码：13211035441 安装运行 # git clone 项目地址 # npm install # gitbook init # gitbook install # gitbook serve 关于GitBook的安装和使用 ➡️ https://www.jianshu.com/p/1f78d8018ea7 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-05 18:53:29 "},"Summary.html":{"url":"Summary.html","title":"项目导航","keywords":"","body":"Summary Part I - 项目简介 项目简介 项目导航 开源项目 个人简历 Part II - 开发笔记 PHP 相关笔记 PSR规范 PSR-0 PSR-1 PSR-2 PSR-3 PSR-4 Composer 类的自动加载 Composer简述 Composer概念解析 Composer使用技巧 Composer自动加载原理 Laravel框架 Laravel常见错误指南 Laravel框架给多个视图分配数据 PHP优化配置 PHP-FPM配置详解 PHP版本新特性 PHP7.0版本新特性 PHP7.1版本新特性 PHP7.2版本新特性 据.md) Mysql开发笔记 Redis开发笔记 Linux开发笔记 Part III - 开发工具 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 15:13:37 "},"php/Readme.html":{"url":"php/Readme.html","title":"PHP 相关笔记","keywords":"","body":"初始化 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-09 20:02:36 "},"php/PSR规范/Readme.html":{"url":"php/PSR规范/Readme.html","title":"PSR规范","keywords":"","body":"PHP编码规范 PSR 是 PHP Standard Recommendations 的简写，由PHP FIG组织制定的 PHP 规范，是 PHP 开发的实践标准。 PHP FIG, FIG 是 Framework Interoperability Group（框架可互用性小组）的缩写，由几位开源框架的开发者成立于 2009 年，从那开始也选取了很多其他成员进来（包括但不限于Laravel, Joomla, Drupal, Composer, Phalcon, Slim, Symfony, Zend Framework等），虽然不是「官方」组织，但也代表了大部分的 PHP 社区。 项目的目的在于：通过框架作者或者框架的代表之间讨论，以最低程度的限制，制定一个协作标准，各个框架遵循统一的编码规范，避免各家自行发展的风格阻碍了 PHP 的发展，解决这个程序设计师由来已久的困扰。 目前官方已制定的规范包括以下六份文件： PSR-0 (已弃用) PSR-1 PSR-2 PSR-2补充 PSR-3 PSR-4 2014/04/25 添加PSR-2补充文件以及修改之前版本中的翻译不当与错误。 2014/07/31 添加PSR-4。 参考链接 PSR - 0 PSR - 1 PSR - 2 PSR - 3 PSR - 4 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 15:02:51 "},"php/PSR规范/PSR-0.html":{"url":"php/PSR规范/PSR-0.html","title":"PSR-0","keywords":"","body":"PSR-0 RS-0规范是他们出的第1套规范，主要是制定了一些自动加载标准（Autoloading Standard)。 目前官网已经废弃了这一规范，以psr-4作为替代。如下文 Deprecated - As of 2014-10-21 PSR-0 has been marked as deprecated. PSR-4 is now recommended as an alternative. 大概意思： 不推荐使用 - 在2014年10月21日PSR-0已被标记为过时。PSR-4现在推荐作为替代。 PSR-0强制性要求几点： 一个完全合格的namespace和class必须符合这样的结构：“\\()*” 每个namespace必须有一个顶层的namespace（\"Vendor Name\"提供者名字） 每个namespace可以有多个子namespace 当从文件系统中加载时，每个namespace的分隔符(/)要转换成 DIRECTORY_SEPARATOR(操作系统路径分隔符) 在类名中，每个下划线(_)符号要转换成DIRECTORY_SEPARATOR(操作系统路径分隔符)。在namespace中，下划线(_)符号是没有（特殊）意义的 当从文件系统中载入时，合格的namespace和class一定是以 .php 结尾的 verdor name,namespaces,class名可以由大小写字母组合而成（大小写敏感的） Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 18:49:01 "},"php/PSR规范/PSR-1.html":{"url":"php/PSR规范/PSR-1.html","title":"PSR-1","keywords":"","body":"PSR-1 基本代码规范 本篇规范制定了代码基本元素的相关标准， 以确保共享的PHP代码间具有较高程度的技术互通性。 关键词 “必须”(“MUST”)、“一定不可/一定不能”(“MUST NOT”)、“需要”(“REQUIRED”)、 “将会”(“SHALL”)、“不会”(“SHALL NOT”)、“应该”(“SHOULD”)、“不该”(“SHOULD NOT”)、 “推荐”(“RECOMMENDED”)、“可以”(“MAY”)和”可选“(“OPTIONAL”)的详细描述可参见 RFC 2119 。 1. 概览 PHP代码文件必须以 2. 文件 2.1. PHP标签 PHP代码必须使用 长标签 或 短输出标签； 一定不可使用其它自定义标签。 2.2. 字符编码 PHP代码必须且只可使用不带BOM的UTF-8编码。 2.3. 从属效应（副作用） 一份PHP文件中应该要不就只定义新的声明，如类、函数或常量等不产生从属效应的操作，要不就只有会产生从属效应的逻辑操作，但不该同时具有两者。 “从属效应”(side effects)一词的意思是，仅仅通过包含文件，不直接声明类、 函数和常量等，而执行的逻辑操作。 “从属效应”包含却不仅限于：生成输出、直接的 require 或 include、连接外部服务、修改 ini 配置、抛出错误或异常、修改全局或静态变量、读或写文件等。 以下是一个反例，一份包含声明以及产生从属效应的代码： \\n\"; // 声明函数 functionfoo(){ // 函数主体部分 } 下面是一个范例，一份只包含声明不产生从属效应的代码： 3. 命名空间和类 命名空间以及类的命名必须遵循 PSR-0. 根据规范，每个类都独立为一个文件，且命名空间至少有一个层次：顶级的组织名称（vendor name）。 类的命名必须 遵循 StudlyCaps 大写开头的驼峰命名规范。 PHP 5.3及以后版本的代码必须使用正式的命名空间。 例如： 5.2.x及之前的版本应该使用伪命名空间的写法，约定俗成使用顶级的组织名称（vendor name）如 Vendor_ 为类前缀。 4. 类的常量、属性和方法 此处的“类”指代所有的类、接口以及可复用代码块（traits） 4.1. 常量 类的常量中所有字母都必须大写，词间以下划线分隔。 参照以下代码： 4.2. 属性 类的属性命名可以遵循 大写开头的驼峰式 ($StudlyCaps)、小写开头的驼峰式 ($camelCase) 又或者是 下划线分隔式 ($under_score)，本规范不做强制要求，但无论遵循哪种命名方式，都应该在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。 4.3. 方法 方法名称必须符合 camelCase() 式的小写开头驼峰命名规范。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 18:49:16 "},"php/PSR规范/PSR-2.html":{"url":"php/PSR规范/PSR-2.html","title":"PSR-2","keywords":"","body":"代码风格规范 本篇规范是 PSR-1 基本代码规范的继承与扩展。 本规范希望通过制定一系列规范化PHP代码的规则，以减少在浏览不同作者的代码时，因代码风格的不同而造成不便。 当多名程序员在多个项目中合作时，就需要一个共同的编码规范， 而本文中的风格规范源自于多个不同项目代码风格的共同特性， 因此，本规范的价值在于我们都遵循这个编码风格，而不是在于它本身。 关键词 “必须”(\"MUST\")、“一定不可/一定不能”(\"MUST NOT\")、“需要”(\"REQUIRED\")、 “将会”(\"SHALL\")、“不会”(\"SHALL NOT\")、“应该”(\"SHOULD\")、“不该”(\"SHOULD NOT\")、 “推荐”(\"RECOMMENDED\")、“可以”(\"MAY\")和”可选“(\"OPTIONAL\")的详细描述可参见 RFC 2119 。 1. 概览 代码必须遵循 PSR-1 中的编码规范 。 代码必须使用4个空格符而不是 tab键 进行缩进。 每行的字符数应该软性保持在80个之内， 理论上一定不可多于120个， 但一定不能有硬性限制。 每个 namespace 命名空间声明语句和 use 声明语句块后面，必须插入一个空白行。 类的开始花括号({)必须写在其声明后自成一行，结束花括号(})也必须写在其主体后自成一行。 方法的开始花括号({)必须写在函数声明后自成一行，结束花括号(})也必须写在函数主体后自成一行。 类的属性和方法必须添加访问修饰符（private、protected 以及 public）， abstract 以及 final 必须声明在访问修饰符之前，而 static 必须声明在访问修饰符之后。 控制结构的关键字后必须要有一个空格符，而调用方法或函数时则一定不能有。 控制结构的开始花括号({)必须写在声明的同一行，而结束花括号(})必须写在主体后自成一行。 控制结构的开始左括号后和结束右括号前，都一定不能有空格符。 1.1. 例子 以下例子程序简单地展示了以上大部分规范： $b) { $foo->bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static function bar() { // method body } } 2. 通则 2.1 基本编码准则 代码必须符合 PSR-1 中的所有规范。 2.2 文件 所有PHP文件必须使用Unix LF (linefeed)作为行的结束符。 所有PHP文件必须以一个空白行作为结束。 纯PHP代码文件必须省略最后的 ?> 结束标签。 2.3. 行 行的长度一定不能有硬性的约束。 软性的长度约束一定要限制在120个字符以内，若超过此长度，带代码规范检查的编辑器一定要发出警告，不过一定不可发出错误提示。 每行不应该多于80个字符，大于80字符的行应该折成多行。 非空行后一定不能有多余的空格符。 空行可以使得阅读代码更加方便以及有助于代码的分块。 每行一定不能存在多于一条语句。 2.4. 缩进 代码必须使用4个空格符的缩进，一定不能用 tab键 。 备注: 使用空格而不是tab键缩进的好处在于， 避免在比较代码差异、打补丁、重阅代码以及注释时产生混淆。 并且，使用空格缩进，让对齐变得更方便。 2.5. 关键字 以及 True/False/Null PHP所有 关键字必须全部小写。 常量 true 、false 和 null 也必须全部小写。 3. namespace 以及 use 声明 namespace 声明后 必须 插入一个空白行。 所有 use 必须 在 namespace 后声明。 每条 use 声明语句 必须 只有一个 use 关键词。 use 声明语句块后 必须 要有一个空白行。 例如： 4. 类、属性和方法 此处的“类”泛指所有的class类、接口以及traits可复用代码块。 4.1. 扩展与继承 关键词 extends 和 implements必须写在类名称的同一行。 类的开始花括号必须独占一行，结束花括号也必须在类主体后独占一行。 implements 的继承列表也可以分成多行，这样的话，每个继承接口名称都必须分开独立成行，包括第一个。 4.2. 属性 每个属性都必须添加访问修饰符。 一定不可使用关键字 var 声明一个属性。 每条语句一定不可定义超过一个属性。 不要使用下划线作为前缀，来区分属性是 protected 或 private。 以下是属性声明的一个范例： 4.3. 方法 所有方法都必须添加访问修饰符。 不要使用下划线作为前缀，来区分方法是 protected 或 private。 方法名称后一定不能有空格符，其开始花括号必须独占一行，结束花括号也必须在方法主体后单独成一行。参数左括号后和右括号前一定不能有空格。 一个标准的方法声明可参照以下范例，留意其括号、逗号、空格以及花括号的位置。 4.4. 方法的参数 参数列表中，每个逗号后面必须要有一个空格，而逗号前面一定不能有空格。 有默认值的参数，必须放到参数列表的末尾。 参数列表可以分列成多行，这样，包括第一个参数在内的每个参数都必须单独成行。 拆分成多行的参数列表后，结束括号以及方法开始花括号 必须 写在同一行，中间用一个空格分隔。 4.5. abstract 、 final 、 以及 static 需要添加 abstract 或 final 声明时， 必须写在访问修饰符前，而 static 则必须写在其后。 4.6. 方法及函数调用 方法及函数调用时，方法名或函数名与参数左括号之间一定不能有空格，参数右括号前也 一定不能有空格。每个逗号前一定不能有空格，但其后必须有一个空格。 bar($arg1); Foo::bar($arg2, $arg3); 参数可以分列成多行，此时包括第一个参数在内的每个参数都必须单独成行。 bar( $longArgument, $longerArgument, $muchLongerArgument ); 5. 控制结构 控制结构的基本规范如下： 控制结构关键词后必须有一个空格。 左括号 ( 后一定不能有空格。 右括号 ) 前也一定不能有空格。 右括号 ) 与开始花括号 { 间一定有一个空格。 结构体主体一定要有一次缩进。 结束花括号 } 一定在结构体主体后单独成行。 每个结构体的主体都必须被包含在成对的花括号之中， 这能让结构体更加结构话，以及减少加入新行时，出错的可能性。 5.1. if 、 elseif 和 else 标准的 if 结构如下代码所示，留意 括号、空格以及花括号的位置， 注意 else 和 elseif 都与前面的结束花括号在同一行。 应该使用关键词 elseif 代替所有 else if ，以使得所有的控制关键字都像是单独的一个词。 5.2. switch 和 case 标准的 switch 结构如下代码所示，留意括号、空格以及花括号的位置。 case 语句必须相对 switch 进行一次缩进，而 break 语句以及 case 内的其它语句都 必须 相对 case 进行一次缩进。 如果存在非空的 case 直穿语句，主体里必须有类似 // no break 的注释。 5.3. while 和 do while 一个规范的 while 语句应该如下所示，注意其 括号、空格以及花括号的位置。 标准的 do while 语句如下所示，同样的，注意其 括号、空格以及花括号的位置。 5.4. for 标准的 for 语句如下所示，注意其 括号、空格以及花括号的位置。 5.5. foreach 标准的 foreach 语句如下所示，注意其 括号、空格以及花括号的位置。 $value) { // foreach body } 5.6. try, catch 标准的 try catch 语句如下所示，注意其 括号、空格以及花括号的位置。 6. 闭包 闭包声明时，关键词 function 后以及关键词 use 的前后都必须要有一个空格。 开始花括号必须写在声明的同一行，结束花括号必须紧跟主体结束的下一行。 参数列表和变量列表的左括号后以及右括号前，必须不能有空格。 参数和变量列表中，逗号前必须不能有空格，而逗号后必须要有空格。 闭包中有默认值的参数必须放到列表的后面。 标准的闭包声明语句如下所示，注意其 括号、逗号、空格以及花括号的位置。 参数列表以及变量列表可以分成多行，这样，包括第一个在内的每个参数或变量都必须单独成行，而列表的右括号与闭包的开始花括号必须放在同一行。 以下几个例子，包含了参数和变量列表被分成多行的多情况。 注意，闭包被直接用作函数或方法调用的参数时，以上规则仍然适用。 bar( $arg1, function ($arg2) use ($var1) { // body }, $arg3 ); 7. 总结 以上规范难免有疏忽，其中包括但不仅限于： 全局变量和常量的定义 函数的定义 操作符和赋值 行内对齐 注释和文档描述块 类名的前缀及后缀 最佳实践 本规范之后的修订与扩展将弥补以上不足。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 14:59:45 "},"php/PSR规范/PSR-3.html":{"url":"php/PSR规范/PSR-3.html","title":"PSR-3","keywords":"","body":"PSR-3 日志接口规范 本文制定了日志类库的通用接口规范。 本规范的主要目的，是为了让日志类库以简单通用的方式，通过接收一个 Psr\\Log\\LoggerInterface 对象，来记录日志信息。 框架以及CMS内容管理系统如有需要，可以对此接口进行扩展，但需遵循本规范， 这才能保证在使用第三方的类库文件时，日志接口仍能正常对接。 关键词 “必须”(“MUST”)、“一定不可/一定不能”(“MUST NOT”)、“需要”(“REQUIRED”)、 “将会”(“SHALL”)、“不会”(“SHALL NOT”)、“应该”(“SHOULD”)、“不该”(“SHOULD NOT”)、 “推荐”(“RECOMMENDED”)、“可以”(“MAY”)和”可选“(“OPTIONAL”)的详细描述可参见 RFC 2119 。 本文中的 实现者 指的是实现了 LoggerInterface 接口的类库或者框架，反过来讲，他们就是 LoggerInterface 的 使用者。 1. 规范说明 1.1 基本规范 LoggerInterface 接口对外定义了八个方法，分别用来记录 RFC 5424 中定义的八个等级的日志：debug、 info、 notice、 warning、 error、 critical、 alert 以及 emergency 。 第九个方法 —— log，其第一个参数为记录的等级。可使用一个预先定义的等级常量作为参数来调用此方法，必须与直接调用以上八个方法具有相同的效果。如果传入的等级常量参数没有预先定义，则必须抛出 Psr\\Log\\InvalidArgumentException 类型的异常。在不确定的情况下，使用者不该使用未支持的等级常量来调用此方法。 1.2 记录信息 以上每个方法都接受一个字符串类型或者是有 __toString() 方法的对象作为记录信息参数，这样，实现者就能把它当成字符串来处理，否则实现者必须自己把它转换成字符串。 记录信息参数可以携带占位符，实现者可以根据上下文将其它替换成相应的值。 其中占位符必须与上下文数组中的键名保持一致。 占位符的名称必须由一个左花括号 { 以及一个右括号 } 包含。但花括号与名称之间一定不能有空格符。 占位符的名称应该只由 A-Z、 a-z,0-9、下划线 _、以及英文的句号 .组成，其它字符作为将来占位符规范的保留。 实现者可以通过对占位符采用不同的转义和转换策略，来生成最终的日志。 而使用者在不知道上下文的前提下，不该提前转义占位符。 以下是一个占位符使用的例子： /** * 用上下文信息替换记录信息中的占位符 */ function interpolate($message, array $context = array()){ // 构建一个花括号包含的键名的替换数组 $replace = array(); foreach ($context as $key => $val) { $replace['{' . $key . '}'] = $val; } // 替换记录信息中的占位符，最后返回修改后的记录信息。 return strtr($message, $replace); } // 含有带花括号占位符的记录信息。 $message = \"User {username} created\"; // 带有替换信息的上下文数组，键名为占位符名称，键值为替换值。 $context = array('username' => 'bolivar'); // 输出 \"Username bolivar created\" echo interpolate($message, $context); 1.3 上下文 每个记录函数都接受一个上下文数组参数，用来装载字符串类型无法表示的信息。它可以装载任何信息，所以实现者必须确保能正确处理其装载的信息，对于其装载的数据，一定不能 抛出异常，或产生PHP出错、警告或提醒信息（error、warning、notice）。 如需通过上下文参数传入了一个 Exception 对象， 必须以 'exception' 作为键名。 记录异常信息是很普遍的，所以如果它能够在记录类库的底层实现，就能够让实现者从异常信息中抽丝剥茧。 当然，实现者在使用它时，必须确保键名为 'exception' 的键值是否真的是一个 Exception，毕竟它可以装载任何信息。 1.4 助手类和接口 Psr\\Log\\AbstractLogger 类使得只需继承它和实现其中的 log 方法，就能够很轻易地实现 LoggerInterface 接口，而另外八个方法就能够把记录信息和上下文信息传给它。 同样地，使用 Psr\\Log\\LoggerTrait 也只需实现其中的 log 方法。不过，需要特别注意的是，在traits可复用代码块还不能实现接口前，还需要 implement LoggerInterface。 在没有可用的日志记录器时， Psr\\Log\\NullLogger 接口可以为使用者提供一个备用的日志“黑洞”。不过，当上下文的构建非常消耗资源时，带条件检查的日志记录或许是更好的办法。 Psr\\Log\\LoggerAwareInterface 接口仅包括一个 setLogger(LoggerInterface $logger) 方法，框架可以使用它实现自动连接任意的日志记录实例。 Psr\\Log\\LoggerAwareTrait trait可复用代码块可以在任何的类里面使用，只需通过它提供的 $this->logger，就可以轻松地实现等同的接口。 Psr\\Log\\LogLevel 类装载了八个记录等级常量。 包 上述的接口、类和相关的异常类，以及一系列的实现检测文件，都包含在 psr/log 文件包中。 3. Psr\\Log\\LoggerInterface 4. Psr\\Log\\LoggerAwareInterface 5. Psr\\Log\\LogLevel Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 18:49:52 "},"php/PSR规范/PSR-4.html":{"url":"php/PSR规范/PSR-4.html","title":"PSR-4","keywords":"","body":"自动载入规范 关键词 “必须”(“MUST”)、“一定不可/一定不能”(“MUST NOT”)、“需要”(“REQUIRED”)、 “将会”(“SHALL”)、“不会”(“SHALL NOT”)、“应该”(“SHOULD”)、“不该”(“SHOULD NOT”)、 “推荐”(“RECOMMENDED”)、“可以”(“MAY”)和”可选“(“OPTIONAL”)。 1. 概述 本 PSR 是关于由文件路径 [自动载入][http://tools.ietf.org/html/rfc2119] 对应类的相关规范， 本规范是可互操作的，可以作为任一自动载入规范的补充，其中包括 PSR-0，此外， 本 PSR 还包括自动载入的类对应的文件存放路径规范。 2. 详细说明 此处的“类”泛指所有的class类、接口、traits可复用代码块以及其它类似结构。 一个完整的类名需具有以下结构: \\(\\)*\\ 完整的类名必须要有一个顶级命名空间，被称为 “vendor namespace”； 完整的类名可以有一个或多个子命名空间； 完整的类名必须有一个最终的类名； 完整的类名中任意一部分中的下滑线都是没有特殊含义的； 完整的类名可以由任意大小写字母组成； 所有类名都必须是大小写敏感的。 当根据完整的类名载入相应的文件…… 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为“命名空间前缀”，其必须与至少一个“文件基目录”相对应； 紧接命名空间前缀后的子命名空间必须与相应的”文件基目录“相匹配，其中的命名空间分隔符将作为目录分隔符。 末尾的类名必须与对应的以 .php 为后缀的文件同名。 自动加载器（autoloader）的实现一定不能抛出异常、一定不能触发任一级别的错误信息以及不应该有返回值。 3. 例子 下表展示了符合规范完整类名、命名空间前缀和文件基目录所对应的文件路径。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 18:10:25 "},"php/composer/Readme.html":{"url":"php/composer/Readme.html","title":"Composer","keywords":"","body":"Readmd.md Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 11:27:46 "},"php/composer/类的自动加载.html":{"url":"php/composer/类的自动加载.html","title":"类的自动加载","keywords":"","body":"起源 很多开发者写面向对象的应用程序时，对每个类的定义建立一个 PHP 源文件。一个很大的烦恼是不得不在每个脚本（每个类一个文件）开头写一个长长的包含文件的列表。 在软件开发的系统中，不可能把所有的类都写在一个PHP文件中，当在一个PHP文件中需要调用另一个文件中声明的类时，就需要通过include把 这个文件引入。不过有的时候，在文件众多的项目中，要一一将所需类的文件都include进来，是一个很让人头疼的事，所以我们能不能在用到什么类的时 候，再把这个类所在的php文件导入呢？这就是我们这里我们要讲的自动加载类。 __autoload() 在 PHP 5 中，可以定义一个 autoload()函数，它会在试图使用尚未被定义的类时自动调 用，通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类， autoload()函数接收的一个参数，就是你想加载的类的 类名，所以你做项目时，在组织定义类的文件名时，需要按照一定的规则，最好以类名为中心，也可以加上统一的前缀或后缀形成文件名，比如 xxx_classname.php、classname_xxx.php以及就是classname.php等等。 本例尝试分别从 MyClass1.php 和 MyClass2.php 文件中加载 MyClass1 和 MyClass2 类 1 spl_autoload_register 尽管 autoload() 函数也能自动加载类和接口, 但是更建议使用 spl_autoload_register() 函数，因为它提供了一种更加灵活的方式来实现类的自动加载(同一个应用中 可以支持任意数量的加载器, 比如第三方库) 因此，不再建议使用 `autoload()` 函数, 在以后的版本中它可能被弃用 doPrint();?> 将autoload换成loadprint函数。但是loadprint不会像autoload自动触发，这时spl_autoload_register()就起作用了，它告诉PHP碰到没有定义的类就执行loadprint()。 spl_autoload_register() 调用静态方法 doPrint();?> 如果同时用spl_autoload_register注册了一个类的方法和__autoload函数，那么，会根据注册的先后，如果在第一个注册的方法或函数里加载了类文件，就不会再执行第二个被注册的类的方法或函数。反之就会执行第二个被注册的类的方法或函数。 注意 : 如果你的电脑大小写敏感，调用spl_autoload_register方法需要注意，他会把类名自动变为小写的。你的文件名称应该是全部小写的才行。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 14:29:56 "},"php/composer/Composer简述.html":{"url":"php/composer/Composer简述.html","title":"Composer简述","keywords":"","body":"简述 Composer 不是一个包管理器。是的，它涉及 \"packages\" 和 \"libraries\"，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理。 这种想法并不新鲜，Composer 受到了 node's npm 和 ruby's bundler的强烈启发。而当时 PHP 下并没有类似的工具。 Composer 将这样为你解决问题： 你有一个项目依赖于若干个库。 其中一些库依赖于其他库。 你声明你所依赖的东西。 Composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。 声明依赖关系 比方说，你正在创建一个项目，你需要一个库来做日志记录。你决定使用 monolog。为了将它添加到你的项目中，你所需要做的就是创建一个 composer.json 文件，其中描述了项目的依赖关系。 { \"require\": { \"monolog/monolog\": \"1.2.*\" } } 我们只要指出我们的项目需要一些 monolog/monolog 的包，从 1.2 开始的任何版本。 系统要求 运行 Composer 需要 PHP 5.3.2+ 以上版本。一些敏感的 PHP 设置和编译标志也是必须的，但对于任何不兼容项安装程序都会抛出警告。 我们将从包的来源直接安装，而不是简单的下载 zip 文件，你需要 git 、 svn 或者 hg ，这取决于你载入的包所使用的版本管理系统。 Composer 是多平台的，我们努力使它在 Windows 、 Linux 以及 OSX 平台上运行的同样出色。 安装 全局安装【推荐】 linux 你可以将此文件放在任何地方。如果你把它放在系统的 PATH 目录中，你就能在全局访问它。 在类Unix系统中，你甚至可以在使用时不加 php 前缀。 你可以执行这些命令让 composer 在你的系统中进行全局调用： curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer 注意： 如果上诉命令因为权限执行失败， 请使用 sudo 再次尝试运行 mv 那行命令。 现在只需要运行 composer 命令就可以使用 Composer 而不需要输入 php composer.phar。 OSX Composer 是 homebrew-php 项目的一部分。 brew update brew tap josegonzalez/homebrew-php brew tap homebrew/versions brew install php55-intl brew install josegonzalez/php/composer Windows 下载并且运行 Composer-Setup.exe，它将安装最新版本的 Composer ，并设置好系统的环境变量，因此你可以在任何目录下直接使用 composer 命令。 使用 继续 上面的例子，composer.json文件已经申明了依赖关系，此时运行： composer install 这里将下载 monolog 到 vendor/monolog/monolog 目录。 自动加载 除了库的下载，Composer 还准备了一个自动加载文件，它可以加载 Composer 下载的库中所有的类文件。使用它，你只需要将下面这行代码添加到你项目的引导文件中： require 'vendor/autoload.php'; 通常你会从所使用框架的单入口文件index.php很快找到这行代码，现在我们就可以使用 monolog 了！ Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 11:28:37 "},"php/composer/Composer概念解析.html":{"url":"php/composer/Composer概念解析.html","title":"Composer概念解析","keywords":"","body":"packagist packagist 是 Composer 的主要资源库。 一个 Composer 的库基本上是一个包的源：记录了可以得到包的地方。Packagist 的目标是成为大家使用库资源的中央存储平台。这意味着你可以 require 那里的任何包。 当你访问 packagist website (packagist.org)，你可以浏览和搜索资源包。 composer.json 文件和vendor目录 项目中使用 Composer获取的组件，只需要一个 composer.json文件生命依赖关系就可以了。该文件包含了项目的依赖和其它的一些元数据。 vendor目录下存放拉下来的composer组件包。 关于require Key 第一件事情（并且往往只需要做这一件事），你需要在composer.json文件中指定 require key 的值。你只需要简单的告诉 Composer 你的项目需要依赖哪些包。 { \"require\": { \"monolog/monolog\": \"1.0.*\" } } 你可以看到， require需要一个 包名称 （例如 monolog/monolog） 映射到 包版本 （例如 1.0.*） 的对象。 包名称 包名称由供应商名称和其项目名称构成。通常容易产生相同的项目名称，而供应商名称的存在则很好的解决了命名冲突的问题。它允许两个不同的人创建同样名为 json 的库，而之后它们将被命名为 igorw/json和 seldaek/json。 这里我们需要引入 monolog/monolog，供应商名称与项目的名称相同，对于一个具有唯一名称的项目，我们推荐这么做。它还允许以后在同一个命名空间添加更多的相关项目。如果你维护着一个库，这将使你可以很容易的把它分离成更小的部分。 包版本 在前面的例子中，我们引入的 monolog 版本指定为 1.0.*。这表示任何从 1.0 开始的开发分支，它将会匹配 1.0.0、1.0.2或者1.0.20。 版本约束 可以用几个不同的方法来指定。 名称 实例 描述 确切的版本号 1.0.2 你可以指定包的确切版本。 范围 >=1.0 >=1.0,=1.0,=1.2 通过使用比较操作符可以指定有效的版本范围。有效的运算符：>、>=、 通配符 1.0.* 你可以使用通配符来指定一种模式。1.0.与>=1.0, 赋值运算符 ~1.2 这对于遵循语义化版本号的项目非常有用。~1.2相当于>=1.2, 下一个重要版本（波浪号运算符） ~ 最好用例子来解释：~1.2相当于>=1.2,，而 ~1.2.3相当于>=1.2.3,。正如你所看到的这对于遵循 语义化版本号 的项目最有用。一个常见的用法是标记你所依赖的最低版本，像 ~1.2（允许1.2以上的任何版本，但不包括2.0）。由于理论上直到2.0应该都没有向后兼容性问题，所以效果很好。你还会看到它的另一种用法，使用 ~指定最低版本，但允许版本号的最后一位数字上升。 注意： 虽然 2.0-beta.1 严格地说是早于 2.0，但是，根据版本约束条件， 例如 ~1.2 却不会安装这个版本。就像前面所讲的 ~1.2 只意味着 .2 部分可以改变，但是 1. 部分是固定的。 稳定性 默认情况下只有稳定的发行版才会被考虑在内。如果你也想获得 RC、beta、alpha 或 dev 版本，你可以使用 稳定标志。你可以对所有的包做 最小稳定性 设置，而不是每个依赖逐一设置。 安装依赖包 推荐使用install命令 composer install 接着前面的例子，这将会找到依赖组件的指定版本，并将它下载到 vendor 目录。 如果你正在使用Git来管理你的项目， 你可能要添加 vendor 到你的 .gitignore 文件中。 你不会希望将所有的代码都添加到你的版本库中。另一件事是 install 命令将创建一个 composer.lock 文件到你项目的根目录中。 composer.lock - 锁文件 在安装依赖后，Composer 将把安装时确切的版本号列表写入 composer.lock 文件。这将锁定改项目的特定版本。 请提交你应用程序的 composer.lock （包括 composer.json）到你的版本库中 这是非常重要的，因为 install命令将会检查锁文件是否存在，如果存在，它将下载指定的版本（忽略composer.json 文件中的定义）。 这意味着，任何人建立项目都将下载与指定版本完全相同的依赖。你的持续集成服务器、生产环境、你团队中的其他开发人员、每件事、每个人都使用相同的依赖，从而减轻潜在的错误对部署的影响。即使你独自开发项目，在六个月内重新安装项目时，你也可以放心的继续工作，即使从那时起你的依赖已经发布了许多新的版本。 如果不存在 composer.lock 文件，Composer 将读取 composer.json 并创建锁文件。 这意味着如果你的依赖更新了新的版本，你将不会获得任何更新。此时要更新你的依赖版本请使用 update 命令。这将获取最新匹配的版本（根据你的 composer.json 文件）并将新版本更新进锁文件。 compose update 如果只想安装或更新一个依赖。 compose update monolog/monolog 还有更多关于composer的操作，推荐查看： phpcomposer中文文档 composer命令全解 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 11:30:10 "},"php/composer/Composer使用技巧.html":{"url":"php/composer/Composer使用技巧.html","title":"Composer使用技巧","keywords":"","body":"一、拉取组件是不是很慢？ 换源（中国全量镜像） 修改 composer 的全局配置文件 打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令： composer config -g repo.packagist composer https://packagist.phpcomposer.com 镜像原理 一般情况下，安装包的数据（主要是 zip 文件）一般是从 github.com 上下载的，安装包的元数据是从 packagist.org 上下载的。 然而，由于众所周知的原因，国外的网站连接速度很慢，并且随时可能被“墙”甚至“不存在”。 “Packagist 中国全量镜像”所做的就是缓存所有安装包和元数据到国内的机房并通过国内的 CDN 进行加速，这样就不必再去向国外的网站发起请求，从而达到加速 composer install 以及 composer update 的过程，并且更加快速、稳定。因此，即使 packagist.org、github.com 发生故障（主要是连接速度太慢和被墙），你仍然可以下载、更新安装包。 二、安装应该使用哪个命令呢，install, update 还是 require ？ 举个例子 这个fork过百的composer管理的组件包，他的安装命令有问题。地址在此。 由于对composer命令的不准确理解，导致出现加载版本错误的情况。 composer update 这个命令在我们现在的逻辑中，可能会对项目造成巨大伤害。 因为composer update的逻辑是按照 composer.json指定的扩展包版本规则，把所有扩展包更新到最新版本，注意，是 所有扩展包，举个例子，你在项目一开始的时候使用了 monolog，当时的配置信息是 \"monolog/monolog\": \"1.*\", 后果 安装的是 monolog 1.1 版本，而一个多月以后的现在，monolog 已经是 1.2 了，运行命令后直接更新到 1.2，这时项目并没有针对 1.2 进行过测试，项目一下子变得很不稳定，情况有时候会比这个更糟糕，尤其是在一个庞大的项目中，你没有对项目写完整覆盖测试的情况，什么东西坏掉了你都不知道。 命令定义 composer install - 如有 composer.lock 文件，直接安装，否则从 composer.json 安装最新扩展包和依赖； composer update - 从 composer.json 安装最新扩展包和依赖； composer update vendor/package - 从 composer.json 或者对应包的配置，并更新到最新； composer require new/package - 添加安装 new/package, 可以指定版本，如： composer require new/package ~2.5. 下来介绍几个日常生产的流程，来方便加深大家的理解。 情景一：开发者引入新组件 创建 composer.json，并添加依赖到的扩展包； 运行 composer install，安装扩展包并生成 composer.lock； 提交 composer.lock 到git代码版本控制器中，不要加入忽略。 情景二：协作者安装现有组件 克隆或者更新项目后，其他开发者引入新的组件，这是我们需要也拉下来。根目录下直接运行 composer install 从 composer.lock 中安装 指定版本 的扩展包以及其依赖； 此流程适用于代码部署。 情景三：为项目添加新组件 使用 composer require vendor/package 添加扩展包， 可以规定版本号，如： composer require \"foo/bar:1.0.0\" 相比较情景一，更推荐require的方式对组件进行添加，升级操作。 三、拉取失败后怎么办？ 分析 每个人是从菜鸡阶段过来的，一开始，我们对 Composer 不熟，用的是官方源，非国内镜像，导致网络不稳定或者很慢很慢导致超时。往往一次不顺之后，再次拉取还是不行。 此时需要检查composer.json是否格式正确，不过一般我们不希望phper自己去修改composer.json文件，因为无论安装，卸载，升级，都可以通过composer命令进行管理。 原因 拉取失败很大几率是网速问题导致的。 解决 先清理cache composer clear-cache // Aliased to clearcache, clears composer's internal package cache. 清理chache之后，再次拉取就可以避免进入失败的死循环，同时建议更换国内源以提高网速和稳定性，如果条件具备可以挂网速稳定的vpn代理科学上网，保证composer顺利工作。 此时我们在项目中使用composer，基本没什么问题了。 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 12:12:43 "},"php/laravel/Readme.html":{"url":"php/laravel/Readme.html","title":"Laravel框架","keywords":"","body":"Readme Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-12 09:59:49 "},"php/laravel/Laravel常见错误指南.html":{"url":"php/laravel/Laravel常见错误指南.html","title":"Laravel常见错误指南","keywords":"","body":"Laravel常见问题总结 1.Whoops, looks like something went wrong. 这个错误代表服务器出现错 解决方法：查看日志以及打开.env 修改APP_DEBUG 为true再重新刷新页面 2.当使用post提交数据时 报The page has expired due to inactivity. Please refresh and try again. 一般这个问题是由于表单缺少csrf令牌时 报错误 或者是路由选择访问的方式不是为post 解决方法 ： 在表单加上{{ csrf_field() }} 这个 或者在web路由更改相应的路由设置 3.Call to undefined function Illuminate\\Encryption\\openssl_cipher_iv_length() 一般出现这个问题是由于服务器缺少openssl这个php拓展 解决方法：装上即可 安装步骤： yum -y install openssl-devel 必须安装 yum -y install openssl-devel 必须安装 cd /lamp/php-7.0.7/ext/openssl mv config0.m4 config.m4 否则报错：找不到config.m4 /usr/local/php/bin/phpize ./configure --with-openssl --with-php-config=/usr/local/php/bin/php-config make make install 4. 禁止访问错误 一般出现这个问题是由于重写模块没有打开 解决方法： 在httpd.conf 中打开rewrite重写模块 在226行左右将 AllowOverride None 设置为All 然后重启apache即可 *FollowSymLinks 允许你的网页文件夹下的链接文件链接到首页目录以外的文件 5.使用composer安装laravel时出现问题 问题1.详解 Failed to download laravel/laravel from dist: The zip extension and unzip command are both missing, skipping. The php.ini used by your command-line PHP is: /usr/local/php/etc/php.ini c出现这个问题是由于环境中缺少zip跟unzip 解决方法 ：yum install zip unzip php7.0-zip 6.当同步更新laravel时发现视图层根本没更新 这是因为laravel 里面的storage\\framework\\views缓存问题 将里面东西都删除即可 7.利用composer装laravel 时报版本错误 命令错误 解决方法composer create-project --prefer-dist laravel/laravel=5.5 blog 8.服务器报500错误 这是由于服务器内部错误 一般是代码错误或者Apache错误 解决方法：打开php.ini 的display_error 中的错误报告 如果是Laravel框架则在配置文件打开调试模式 或者是缺少env这个文件 这个问题一般是由于git克隆或者直接复制文件夹问题 9.No application encryption key has been specified. 这是因为.env 配置文件中缺少key这个秘钥 解决方法； hp artisan key:generate 10 如果ajax post发起请求 出现419错误 由于没有csrf_token令牌的原因 解决方法： 在页面头部加一行 然后在ajax 的请求头里加多一行headers: {'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content')}, Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-05 20:15:03 "},"php/PHP优化配置/Readme.html":{"url":"php/PHP优化配置/Readme.html","title":"PHP优化配置","keywords":"","body":"初始化 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-09 20:02:36 "},"php/PHP优化配置/PHP-FPM配置详解.html":{"url":"php/PHP优化配置/PHP-FPM配置详解.html","title":"PHP-FPM配置详解","keywords":"","body":"前言 本文章会详细介绍php-fpm配置文件的各个配置值，以及对应关系，目前大多数PHP应用采用nginx + php-fpm 的方式去运作，所以了解php-fpm的配置对优化服务器会有很大的帮助 配置详解 该配置为 Ubuntu 18.04 下 通过apt-get install 安装的php7.3-fpm生成的配置文件 运行php-fpm的用户以及用户组配置 user = www-data --运行php-fpm的用户 group = www-data --运行php-fpm的用户组 监听php-fpm的方式 listen = /run/php/php7.3-fpm.sock --fpm监听的sock文件 listen = 127.0.0.1:9000 --fpm监听的端口 监听php-fpm的方式有两种 第一次种是Unix domain socket模式 另外一种是TCP模式, TCP是使用TCP端口连接127.0.0.1:9000，Socket是使用unix domain socket连接套接字/dev/shm/php-cgi.sock，在服务器压力不大的情况下，tcp和socket差别不大，但在压力比较满的时候，用套接字方式，效果确实比较好。 从原理上来说，unix socket方式肯定要比tcp的方式快而且消耗资源少，因为socket之间在nginx和php-fpm的进程之间通信，而tcp需要经过本地回环驱动，还要申请临时端口和tcp相关资源。 当然还是从原理上来说，unix socket会显得不是那么稳定，当并发连接数爆发时，会产生大量的长时缓存，在没有面向连接协议支撑的情况下，大数据包很有可能就直接出错并不会返回异常。而TCP这样的面向连接的协议，多少可以保证通信的正确性和完整性。其实如果nginx做要做负载均衡的话，根本也不要考虑unix socket的方式了，只能采用TCP的方式。 backlog数 listen.backlog = 1024 ---1表示无限制，由操作系统决定，此行注释掉就行。 监听的用户以及用户组 listen.owner = www-data listen.group = www-data 允许监听的客户端 ip listen.allowed_clients = 127.0.0.1 Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-09 20:55:48 "},"php/PHP版本新特性/Readme.html":{"url":"php/PHP版本新特性/Readme.html","title":"PHP版本新特性","keywords":"","body":"PHP各个版本新特性（7.0-7.2） php7发布已经升级到7.2.里面发生了很多的变化。本文整理php7.0至php7.2的新特性和一些变化。 参考资料： http://php.net/manual/zh/migration70.new-features.php http://php.net/manual/zh/migration71.new-features.php http://php.net/manual/zh/migration72.new-features.php Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 16:24:57 "},"php/PHP版本新特性/PHP7.0版本新特性.html":{"url":"php/PHP版本新特性/PHP7.0版本新特性.html","title":"PHP7.0版本新特性","keywords":"","body":"PHP7.0版本新特性 1. 组合比较符 () 组合比较符号用于比较两个表达式。当$a小于、等于或大于$b时它分别返回-1、0或1，比较规则延续常规比较规则。对象不能进行比较 var_dump('PHP' 'Node'); // int(1) var_dump(123 456); // int(-1) var_dump(['a', 'b'] ['a', 'b']); // int(0) 2. null合并运算符 由于日常使用中存在大量同时使用三元表达式和isset操作。使用null合并运算符可以简化操作 # php7以前 if(isset($_GET['a'])) { $a = $_GET['a']; } # php7以前 $a = isset($_GET['a']) ? $_GET['a'] : 'none'; #PHP 7 $a = $_GET['a'] ?? 'none'; 3. 变量类型声明 变量类型声明有两种模式。一种是强制的，和严格的。允许使用下列类型参数int、string、float、bool 同时不能再使用int、string、float、bool作为类的名字了 function sumOfInts(int ...$ints) { return array_sum($ints); } var_dump(sumOfInts(2, '3', 4.1)); // int(9) # 严格模式 declare(strict_types=1); function add(int $x, int $y) { return $x + $y; } var_dump(add('2', 3)); // Fatal error: Argument 1 passed to add() must be of the type integer 5. 返回值类型声明 增加了返回类型声明，类似参数类型。这样更方便的控制函数的返回值.在函数定义的后面加上:类型名即可 function fun(int $a): array { return $a; } fun(3);//Fatal error 6. 匿名类 php7允许new class {} 创建一个匿名的对象。 //php7以前 class Logger { public function log($msg) { echo $msg; } } $util->setLogger(new Logger()); // php7+ $util->setLogger(new class { public function log($msg) { echo $msg; } }); 7. Unicode codepoint 转译语法 这接受一个以16进制形式的 Unicode codepoint，并打印出一个双引号或heredoc包围的 UTF-8 编码格式的字符串。 可以接受任何有效的 codepoint，并且开头的 0 是可以省略的 echo \"\\u{aa}\";// ª echo \"\\u{0000aa}\";// ª echo \"\\u{9999}\";// 香 8. Closure::call 闭包绑定 简短干练的暂时绑定一个方法到对象上闭包并调用它。 class A {private $x = 1;} // PHP 7 之前版本的代码 $getXCB = function() {return $this->x;}; $getX = $getXCB->bindTo(new A, 'A'); // 中间层闭包 echo $getX(); // PHP 7+ 及更高版本的代码 $getX = function() {return $this->x;}; echo $getX->call(new A); 9. 带过滤的unserialize 提供更安全的方式解包不可靠的数据。它通过白名单的方式来防止潜在的代码注入 // 将所有的对象都转换为 __PHP_Incomplete_Class 对象 $data = unserialize($foo, [\"allowed_classes\" => false]); // 将除 MyClass 和 MyClass2 之外的所有对象都转换为 __PHP_Incomplete_Class 对象 $data = unserialize($foo, [\"allowed_classes\" => [\"MyClass\", \"MyClass2\"]); // 默认情况下所有的类都是可接受的，等同于省略第二个参数 $data = unserialize($foo, [\"allowed_classes\" => true]); 10. IntlChar类 这个类自身定义了许多静态方法用于操作多字符集的 unicode 字符。需要安装intl拓展 printf('%x', IntlChar::CODEPOINT_MAX); echo IntlChar::charName('@'); var_dump(IntlChar::ispunct('!')); 11. 预期 它使得在生产环境中启用断言为零成本，并且提供当断言失败时抛出特定异常的能力。以后可以使用这个这个进行断言测试 ini_set('assert.exception', 1); class CustomError extends AssertionError {} assert(false, new CustomError('Some error message')); 12. 命名空间按组导入 从同一个命名空间下导入的类、函数、常量支持按组一次导入 #php7以前 use app\\model\\A; use app\\model\\B; #php7+ use app\\model{A,B} 13.生成器支持返回表达式 它允许在生成器函数中通过使用 return 语法来返回一个表达式 （但是不允许返回引用值）， 可以通过调用 Generator::getReturn() 方法来获取生成器的返回值， 但是这个方法只能在生成器完成产生工作以后调用一次。 $gen = (function() { yield 1; yield 2; return 3; })(); foreach ($gen as $val) { echo $val, PHP_EOL; } # output //1 //2 echo $gen->getReturn(), PHP_EOL; # output //3 14.生成器委派 现在，只需在最外层生成其中使用yield from，就可以把一个生成器自动委派给其他的生成器 function gen() { yield 1; yield 2; yield from gen2(); } function gen2() { yield 3; yield 4; } foreach (gen() as $val) { echo $val, PHP_EOL; } 15.整数除法函数intdiv var_dump(intdiv(10,3)) //3 16.会话选项设置 session_start() 可以加入一个数组覆盖php.ini的配置 session_start([ 'cache_limiter' => 'private', 'read_and_close' => true, ]); 18. 随机数、随机字符函数 string random_bytes(int length); int random_int(int min, int max); 19. define 支持定义数组 #php7+ define('ALLOWED_IMAGE_EXTENSIONS', ['jpg', 'jpeg', 'gif', 'png']); Copyright © Choice→選の博客 2019 all right reserved，powered by Gitbook修订时间： 2019-08-10 17:58:36 "}}